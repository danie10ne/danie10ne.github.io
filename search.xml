<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>什么是SOCKET连接？</title>
      <link href="2020/10/07/wang-luo/shi-me-shi-socket-lian-jie/"/>
      <url>2020/10/07/wang-luo/shi-me-shi-socket-lian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SOCKET连接？"><a href="#什么是SOCKET连接？" class="headerlink" title="什么是SOCKET连接？"></a>什么是SOCKET连接？</h1><h2 id="1-套接字（socket）概念"><a href="#1-套接字（socket）概念" class="headerlink" title="1. 套接字（socket）概念"></a>1. 套接字（socket）概念</h2><ul><li>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，也是其中间抽象层接口，Scoket将TCP/IP复杂的处理方法隐藏在接口之后，对于用户而言只需要调用Scoket接口服务即可获取相应网络服务。</li><li>包含进行网络通信必须的五种信息：<strong>连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</strong></li><li>socket 其实就是一个五元组，包括：<strong>源IP, 源端口, 目的IP, 目的端口, 类型(TCP or UDP)</strong> 这个五元组，即标识了一条可用的连接。</li></ul><blockquote><p>为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p></blockquote><p><img src="/Users/daniel/Documents/blog/source/pictures/socket.png" alt="socket"></p><h2 id="2-建立socket连接"><a href="#2-建立socket连接" class="headerlink" title="2. 建立socket连接"></a>2. 建立socket连接</h2><ul><li>建立Socket连接至少需要一对套接字</li><li>ClientSocket运行于客户端</li><li>ServerSocket运行于服务器端</li></ul><p><strong>套接字之间的连接过程分为三个步骤：</strong></p><ol><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li><li>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ol><h2 id="3-Socket通信过程"><a href="#3-Socket通信过程" class="headerlink" title="3. Socket通信过程"></a>3. Socket通信过程</h2><p><strong>客户端请求</strong> -&gt; 序列化 -&gt; write buffer -&gt; socket -&gt; TCP/IP or UDP -&gt; 客户端链路 -&gt; 交换机 -&gt; 路由 -&gt; 交换机 -&gt; 服务端链路 -&gt; TCP/IP or UDP -&gt; socket -&gt; read buffer -&gt; 反序列化 -&gt; <strong>服务端响应</strong> -&gt; 序列化 -&gt; write buffer -&gt; socket -&gt; TCP/IP or UDP -&gt; 服务端链路 -&gt; 交换机 -&gt; 路由 -&gt; 交换机 -&gt; <strong>客户端接收响应</strong> -&gt; 链路 -&gt; TCP/IP or UDP -&gt; socket -&gt; read buffer -&gt; <strong>关闭连接</strong></p><p><strong>服务端</strong></p><ol><li><p>初始化Socket<code>socket()</code></p></li><li><p>与端口绑定<code>bind()</code></p></li><li><p>对端口进行监听<code>listen()</code></p></li><li><p>调用<code>accept()</code>堵塞等待客户端连接</p></li></ol><p><strong>客户端</strong></p><ol><li>初始化Socket<code>socket()</code></li><li>与端口绑定<code>bind()</code></li><li>连接服务端<code>connect()</code></li><li>连接成功，发送请求<code>write()</code></li></ol><p>客户端首先封装一个请求对象<code>req</code>，将其序列化成为字节数组（序列化后的请求消息对象<code>req</code>），同时拷贝到操作系统到内核区套接字对象的<code>write buffer</code>中，内核网络模块会有单独的线程负责不停地将<code>write buffer</code>的数据拷贝到网卡硬件，网卡硬件再将数据传送到网线，经过一系列路由器和交换机，最终送达服务器的网卡硬件中。</p><p><strong>服务端</strong></p><ol><li>接收请求并处理<code>read()</code></li><li>将回应发送给客户端<code>write()</code></li></ol><p>服务端内核的网络模块也有单独的线程不停地接收到数据拷贝到套接字的<code>read buffer</code>中等待用户层来读取，最终服务端的用户进程通过socket引用的<code>read()</code>方法将<code>read buffer</code>中的数据拷贝到用户程序内部中，进行反序列化成请求对象<code>req</code>进行处理，然后服务端将处理后的响应对象，按相反的流程发送给客户端。</p><p><strong>客户端</strong></p><ol><li>读取来自服务端的响应<code>read()</code></li><li>关闭连接<code>close()</code>，交互结束  </li></ol><p><img src="/Users/daniel/Documents/blog/source/_posts/pictures/socket_response.png" alt="socket_response"></p><h2 id="4-Socket连接与TCP连接"><a href="#4-Socket连接与TCP连接" class="headerlink" title="4. Socket连接与TCP连接"></a>4. Socket连接与TCP连接</h2><ul><li>创建Socket连接时，可以指定使用的传输层协议</li><li>Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</li></ul><h2 id="5-Socket连接与HTTP连接"><a href="#5-Socket连接与HTTP连接" class="headerlink" title="5. Socket连接与HTTP连接"></a>5. Socket连接与HTTP连接</h2><ul><li>HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</li><li>若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端。</li><li>若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 套接字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/07/java-ji-chu/java8/"/>
      <url>2020/10/07/java-ji-chu/java8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/07/java-ji-chu/dong-tai-dai-li/"/>
      <url>2020/10/07/java-ji-chu/dong-tai-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/07/java-ji-chu/fan-she/"/>
      <url>2020/10/07/java-ji-chu/fan-she/</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="2020/10/07/wang-luo/io/"/>
      <url>2020/10/07/wang-luo/io/</url>
      
        <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="1-什么是IO"><a href="#1-什么是IO" class="headerlink" title="1. 什么是IO"></a>1. 什么是IO</h2><p>IO简单理解就是用来传输的工具负责：输入/输出。</p><p>在JDK中有针对不同IO需求的包，比如：</p><ul><li><p>磁盘操作：Paths  Files</p><ul><li>向磁盘写入数据</li><li>从磁盘中读数据</li></ul></li><li><p>字节操作：</p><ul><li>字节流输入操作InputStream </li><li>字节流输出操作Outputstream</li><li>操作byte类型的数据，不会使用缓冲区，直接对文件进行操作，实现文件复制、音频文件处理等</li></ul></li><li><p>字符操作：Writer Reader</p><ul><li>操作字符类型的数据，使用缓冲区，因此必须执行close关闭缓冲区或者flush强制刷新缓冲区才能输出内容，用于编码操作，编码就是把字符转换成字节，解码就是把字节转换成字符。</li><li>OutputStreamWriter 将字符流编码成为字节流</li><li>InputStreamReader 将字节流解码成字符流</li></ul></li><li><p>对象操作Serializable：序列化就是将一个对象转换成字节序列，方便存储和传输</p><ul><li>序列化：ObjectOutputStream.writeObject() </li><li>反序列化：ObjectInputStream.readObject()</li></ul></li><li><p>网络操作：</p><ul><li><p>InetAddress：没有公有的构造函数，只能通过静态方法来创建实例。</p></li><li><p>URL：可以直接从 URL 中读取字节流数据。</p></li><li><p>Socket：</p><ul><li><p>ServerSocket：服务器端类 </p></li><li><p>Socket：客户端类 </p></li><li><p>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</p><p><img src="/Users/daniel/Documents/blog/source/pictures/scoket2.png" alt="scoket2"></p></li></ul></li></ul></li></ul><h2 id="2-不同IO模型"><a href="#2-不同IO模型" class="headerlink" title="2. 不同IO模型"></a>2. 不同IO模型</h2><ul><li><p>阻塞IO：在读写数据过程中，如果数据未准备好，则线程会被阻塞直到数据准备好</p></li><li><p>非阻塞IO</p><p>在读写数据过程中，如果数据未准备好，线程无需等待，而是继续执行，重复询问数据是否准备好，但于此同时会消耗大量的内存资源，因为用户线程需要不断地询问内核数据是否就绪，实质上是一直占用着CPU的。</p></li><li><p>复用IO —&gt; NIO</p><p>在多路复用IO模型中，有一个<code>额外的线程</code>不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。只需要一个额外的线程管理多个数据请求线程或进程，只有在数据准备好了之后，请求才会占用CPU资源，因此节省了内存资源。</p></li><li><p>信号驱动IO</p><p>当用户线程发起一个IO请求操作，会给对应的socket注册一个<code>信号函数</code>，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p></li><li><p>异步IO —&gt; AIO</p><p>在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成，但是异步IO是需要操作系统的底层支持。</p><blockquote><p> 前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p></blockquote></li></ul><h2 id="3-BIO、NIO、AIO"><a href="#3-BIO、NIO、AIO" class="headerlink" title="3. BIO、NIO、AIO"></a>3. BIO、NIO、AIO</h2><p>BIO：同步阻塞IO，开水例子：用户线程</p><p>NIO：原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。流式处理按字节处理数据，处理简单但是速度较慢，以块的形式读写数据的方法，这使得即使在面向流的系统中处理数据，速度也会更快。</p><p>AIO：异步非阻塞IO。</p><p>假设一个烧开水的场景，有一排水壶在烧开水。</p><p>BIO：用一个线程停留在一个水壶那里，直到这个水壶烧开，才去处理下一个水壶。</p><p>NIO：用一个线程不断地轮询各个水壶的状态，如果水开了，用户线程或者线程过来进行进一步操作（从内核拷贝准备好的数据）</p><p>AIO：给每个水壶安装一个状态开关，如果水壶的水开了（数据读写已经完成），水壶会自动通知系统，用户线程做进一步操作（拿数据）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现getMin栈</title>
      <link href="2020/10/07/shu-ju-jie-gou-yu-suan-fa/zhan/shi-xian-getmin-zhan/"/>
      <url>2020/10/07/shu-ju-jie-gou-yu-suan-fa/zhan/shi-xian-getmin-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="实现getMin栈"><a href="#实现getMin栈" class="headerlink" title="实现getMin栈"></a>实现getMin栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>第一行输入一个整数N，表示对栈进行的操作总数。下面N行每行输入一个字符串S，表示操作的种类。如果S为"push"，则后面还有一个整数X表示向栈里压入整数X。如果S为"pop"，则表示弹出栈顶操作。如果S为"getMin"，则表示询问当前栈中的最小元素是多少。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code>对于每个getMin操作，输出一行表示当前栈中的最小元素是多少。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>6push 3push 2push 1getMinpopgetMin</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>12</code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><pre><code>1&lt;=N&lt;=1000000-1000000&lt;=X&lt;=1000000数据保证没有不合法的操作</code></pre><h2 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h2><ul><li>使用两个栈</li><li>stackData：保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData；另一个栈用于保存每一步的最小值，这个栈记为stackMin”</li><li>stackMin：最小栈，保存每一步操作时的最小值</li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">minStack</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stackData<span class="token punctuation">;</span>        <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stackMin<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//初始化两个栈</span>        <span class="token keyword">public</span> <span class="token function">minStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>stackData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>stackMin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//push操作：如果push元素小于最小栈的栈顶元素，data需push到最小栈</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>            stackData<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stackMin<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>                stackMin<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>                stackMin<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//peek最小栈栈顶元素即可</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//记住要同时pop两个栈的栈顶元素</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stackData<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> stackMin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                stackData<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                stackMin<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//基于whiteboard将输入样例输入，要注意编写格式的转换</span>      <span class="token comment" spellcheck="true">//使用BufferedReader创建输入实例</span>      <span class="token comment" spellcheck="true">//使用Integer.parseInt转换参数格式</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">{</span>        minStack stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">minStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BufferedReader scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//输入操作，同时去除 具体操作和数字之间的空格</span>            <span class="token comment" spellcheck="true">//String[0]表示操作类型 String[1]表示参数</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> operate <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"push"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"pop"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"getMin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        scanner<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型中的上下限通配符extends、super</title>
      <link href="2020/10/06/java-ji-chu/java-fan-xing-zhong-de-shang-xia-xian-tong-pei-fu-extends-super/"/>
      <url>2020/10/06/java-ji-chu/java-fan-xing-zhong-de-shang-xia-xian-tong-pei-fu-extends-super/</url>
      
        <content type="html"><![CDATA[<h1 id="Java泛型中的上下限通配符extends、super"><a href="#Java泛型中的上下限通配符extends、super" class="headerlink" title="Java泛型中的上下限通配符extends、super"></a>Java泛型中的上下限通配符extends、super</h1><p>在平时看源码的时候我们经常看到泛型，且经常会看到<code>extends</code>和<code>super</code>的使用，看过其他的文章里也有讲到上界通配符和下届通配符，总感觉讲的不够明白。这里备注一下，以免忘记。</p><ol><li><code>extends</code>也称为上界通配符，就是指定上边界。即泛型中的类必须为当前类的子类或当前类。</li><li><code>super</code>也称为下届通配符，就是指定下边界。即泛型中的类必须为当前类或者其父类。</li></ol><p>这两点不难理解，<code>extends</code>修饰的只能取，不能放，这是为什么呢？</p><p>先看一个列子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Food</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token keyword">extends</span> <span class="token class-name">Food</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Banana</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testExtends</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//报错,extends为上界通配符,只能取值,不能放.</span>        <span class="token comment" spellcheck="true">//因为Fruit的子类不只有Apple还有Banana,这里不能确定具体的泛型到底是Apple还是Banana，所以放入任何一种类型都会报错</span>        <span class="token comment" spellcheck="true">//list.add(new Apple());</span>        <span class="token comment" spellcheck="true">//可以正常获取</span>        Fruit fruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSuper</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Fruit<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//super为下界通配符，可以存放元素，但是也只能存放当前类或者子类的实例，以当前的例子来讲，</span>        <span class="token comment" spellcheck="true">//无法确定Fruit的父类是否只有Food一个(Object是超级父类)</span>        <span class="token comment" spellcheck="true">//因此放入Food的实例编译不通过</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//list.add(new Food());</span>        Object object <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在<code>testExtends</code>方法中，因为泛型中用的是<code>extends</code>，在向<code>list</code>中存放元素的时候，我们并不能确定<code>List</code>中的元素的具体类型，即可能是<code>Apple</code>也可能是<code>Banana</code>。因此调用<code>add</code>方法时，不论传入<code>new Apple()</code>还是<code>new Banana()</code>，都会出现编译错误。</p><p>理解了<code>extends</code>之后，再看<code>super</code>就很容易理解了，即我们不能确定<code>testSuper</code>方法的参数中的泛型是<code>Fruit</code>的哪个父类，因此在调用<code>get</code>方法时只能返回<code>Object</code>类型。结合<code>extends</code>可见，在获取泛型元素时，使用<code>extends</code>获取到的是泛型中的上边界的类型(本例子中为Fruit),范围更小。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在使用泛型时，存取元素时用<code>super</code>,获取元素时，用<code>extends</code>。</p><p>本文来源：<a href="https://juejin.im/post/5c653fe06fb9a049e3089d88">https://juejin.im/post/5c653fe06fb9a049e3089d88</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类</title>
      <link href="2020/10/06/java-ji-chu/java-ji-he-lei/"/>
      <url>2020/10/06/java-ji-chu/java-ji-he-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h1><h2 id="1-Collection-和-Collections-区别"><a href="#1-Collection-和-Collections-区别" class="headerlink" title="1. Collection 和 Collections 区别"></a>1. Collection 和 Collections 区别</h2><p>Collection是集合的接口，提供了多个通用的接口方法，供诸如list、set等实现。</p><p>Collections是一个包装类，其内部的方法都为静态方法，因此不能被实例化，作为工具类使用。</p><h2 id="2-常用集合类"><a href="#2-常用集合类" class="headerlink" title="2. 常用集合类"></a>2. 常用集合类</h2><h3 id="1）Set和List的区别"><a href="#1）Set和List的区别" class="headerlink" title="1）Set和List的区别"></a>1）Set和List的区别</h3><p><strong>共同点：</strong>都继承自Collection接口，都用来存储一组相同类型的元素</p><p><strong>不同点：</strong></p><ul><li>list元素按顺序放入，即先来的排在前边且元素是可以重复的</li><li>set元素没有放入顺序，且元素不可重复，所以set可以用来去重</li></ul><h3 id="2）ArrayList-、LinkedList-和-Vector-的区别"><a href="#2）ArrayList-、LinkedList-和-Vector-的区别" class="headerlink" title="2）ArrayList 、LinkedList 和 Vector 的区别"></a>2）ArrayList 、LinkedList 和 Vector 的区别</h3><p><strong>共同点：</strong>ArrayList 和 LinkedList 和 Vector 是List的是三种实现。</p><p><strong>不同点</strong></p><p><strong>ArrayList：</strong>是一个<strong>大小可以改变的数组</strong>，随着数组内元素的增加，其大小将会动态的增加，通过set或者get方法来获取数组内的元素，其查找性能要优于链表，增删性能弱于链表。</p><p><strong>LinkedList：</strong>是一个<strong>双向链表</strong>，增删操作很快，随机访问性能较差。LinkedList还实现了Queue接口，提供了队列相关的操作，比如poll、peek、offer。</p><p><strong>Vector：</strong>与ArrayList类似，但是<strong>Vector是线程安全的</strong>，在没有多个线程共享同一个集合的情况下，建议使用ArrayList。Vector每次请求其大小双倍的空间，而ArrayList每次对size只增长50%。</p><h3 id="4）Set如何保证元素不重复？"><a href="#4）Set如何保证元素不重复？" class="headerlink" title="4）Set如何保证元素不重复？"></a>4）Set如何保证元素不重复？</h3><p>在Java中Set分为两种：TreeSet和HashSet</p><p><strong>TreeSet：</strong>TreeSet的底层是通过TreeMap（红黑树）来实现的，Treeset中的数据是自动排好序的，红黑树实质是一个二叉平衡搜索树，每个节点的左右子树高度不能超过较矮那棵的一倍。</p><p>在TreeSet中插入新元素时，通过调用compareTo()方法来判断元素是否重复，且不允许放入null值。</p><p><strong>HashSet：</strong>HashSet的底层是通过HashMap来实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null。插入新元素时，首先计算新元素的hashcode，再通过扰动计算和按位计算得到此元素在HashMap存储结构中的存放位置，如果此位置为空，则添加此元素，如果不为空，则通过重写了的equal()方法，判断当前插入元素是否与已存在元素相等，如果不相等则添加新元素，相等则不添加。</p><h3 id="5）LinkedHashMap"><a href="#5）LinkedHashMap" class="headerlink" title="5）LinkedHashMap"></a>5）LinkedHashMap</h3><p>继承自HashMap，因此具有快速查找的特性，同时内部维护了一个双向链表，用来维护LRU顺序或者插入顺序。</p><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p><strong>afterNodeAccess()</strong></p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在 每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><p><strong>afterNodeInsertion()</strong></p><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 ﬁrst。</p><p><strong>使用LinkedHashMap实现LRU</strong></p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>accessOrder = true//开启 LRU 顺序</li><li>覆盖 removeEldestEntry()方法，在节点数大于MAX_ENTRIES时会将最近最久未使用的数据移除</li></ul><p>通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><h2 id="3-HashMap的实现原理"><a href="#3-HashMap的实现原理" class="headerlink" title="3. HashMap的实现原理"></a>3. HashMap的实现原理</h2><p><strong>JDK1.7</strong></p><p>HashMap通过<strong>数组+链表</strong>存储数据，内部包含一个Entry类的数组，Entry类包含四个字段，<code>k、v、next、hash</code>来实现数组和链表的结构存储数据。</p><p><strong>插入put：</strong></p><p>在插入新元素时，不同元素的hash值可能相同，也就意味着hash冲突，在1.7版本中解决hash冲突的办法是使用<strong>拉链法</strong>，新插入的元素插入到对应entry链表的头部（头插法），之所以采用头插法是新插入的元素可能更容易被查找。</p><p><strong>常见的解决碰撞的方法</strong></p><ul><li><p>开放定址法</p><p>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p></li><li><p>链地址法</p><p>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</p></li><li><p>再哈希法</p><p>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</p></li><li><p>建立公共溢出区</p><p>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</p></li></ul><p><strong>查找get：</strong></p><ul><li>计算键值对所在的桶Entry</li><li>在链表上顺序查找，时间复杂度与链表的长度成正比，最坏时间复杂度为O(N)</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算hash</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确定桶下标：按位与取模</span></code></pre><p><strong>JDK1.8</strong></p><p>同样使用数组和链表存储数据，但是在一个桶存储的链表长度大于 8 时，会将链表转换为红黑树。这样做是为了避免在链表长度过长时，将遍历链表元素的时间复杂度从O(N)降为O(logN)。</p><p><strong>扩容</strong></p><p>与扩容相关的参数有：：capacity、size、threshold 和 load_factor</p><p>当HashMap存储的元素个数超过threshold过载时<code>threshold = loadFactor * capacity</code>，会触发扩容，且<strong>自动双倍扩容，扩容后重新计算每个键值对位置。</strong></p><p><code>capacity</code>默认为16，且capacity 必须保证为 2 的 n 次方，每次扩容时，capacity 为原来的两倍。size表示当前共有多少个K-V对，当 size 大于等于 threshold 就必须进行扩容操作。loadFactor是负载因子，负载因子一般定为0.75。</p><ul><li><p>为什么负载因子一般定为0.75</p><p>在计算hashmap是否达到扩容标准时，负载因子0.75 = 3/4，与capacity的乘积正好可以为整数。</p></li><li><p>为什么容量必须保证为 2 的 n 次方？</p><p>因为hashmap通过取模获取元素的entry位置时，是通过按位与的方式实现快速查找Entry位置的，而要使得按位与和取余等价则必须保证容量是 2 的 n 次方。</p><pre class=" language-java"><code class="language-java">X <span class="token operator">%</span> <span class="token number">2</span><span class="token operator">^</span>n <span class="token operator">=</span> X <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>n – <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//X表示hash值</span></code></pre></li><li><p>为什么按位与取模？</p><p>这样做的好处是相比于使用“%”取模，不需要将hash转为int计算，节省计算成本，同时按位与的话也避免了复杂的正负计算，因为hash值为int类型</p></li></ul><h2 id="5-ConcurrentHashMap-的实现原理"><a href="#5-ConcurrentHashMap-的实现原理" class="headerlink" title="5. ConcurrentHashMap 的实现原理"></a>5. ConcurrentHashMap 的实现原理</h2><p><strong>JDK1.7</strong></p><p>在桶数组的基础上，加入了<strong>分段锁</strong>，将数据按分成一段一段的存储，然后给每一段数据分配一个锁，当一个线程访问占用某一段数据的锁，访问此段数据时，其他分段的数据可以被其他线程访问，实现线程安全。</p><p>其核心类为 Segment，它继承自<strong>重入锁 ReentrantLock</strong>，并发度与 Segment 数量相等，默认的并发级别是16。</p><p><strong>JDK1.8</strong></p><p>使用<strong>CAS操作</strong>支持更高的并发量，在CAS操作失败时，使用<strong>内置锁synchronized</strong>，且在链表长度过长时，将转为红黑树来存储数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit使用</title>
      <link href="2020/10/06/java-ji-chu/junit/"/>
      <url>2020/10/06/java-ji-chu/junit/</url>
      
        <content type="html"><![CDATA[<h1 id="JUnit使用"><a href="#JUnit使用" class="headerlink" title="JUnit使用"></a>JUnit使用</h1><h2 id="JUnit特性"><a href="#JUnit特性" class="headerlink" title="JUnit特性"></a>JUnit特性</h2><p>JUnit是一个Java语言的单元测试框架，JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。</p><ul><li><p>一个正式的编写好的单元测试用例的特点是：<strong>已知输入和预期输出，即在测试执行前就已知</strong>。已知输入需要测试的先决条件，预期输出需要测试后置条件。</p></li><li><p>每一项需求至少需要两个单元测试用例：<strong>一个正检验，一个负检验</strong>。如果一个需求有子需求，每一个子需求必须至少有正检验和负检验两个测试用例。</p></li></ul><h2 id="Spring-Boot-基于-JUnit-5-实现单元测试"><a href="#Spring-Boot-基于-JUnit-5-实现单元测试" class="headerlink" title="Spring Boot 基于 JUnit 5 实现单元测试"></a>Spring Boot 基于 JUnit 5 实现单元测试</h2><ol><li><p>创建Springboot工程</p></li><li><p>添加 <code>spring-boot-starter-web</code> 依赖</p></li><li><p>工程创建好后会自动生成一个测试类，用于检查工程的上下文能否正常启动。</p><p><code>@SpringBootTest</code> 注解告诉 Spring Boot 查找带 <code>@SpringBootApplication</code> 注解的主配置类，并使用该类启动 Spring 应用程序上下文。</p></li><li><p>编写业务逻辑测试代码类</p><ul><li>测试类需要添加注解<code>@SpringBootTest</code>，测试方法需要添加<code>@Test</code></li><li>测试方法中调用JUnit中的api来判断测试样例输入输出是否符合既定要求</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么时候需要将对象序列化？</title>
      <link href="2020/10/06/java-ji-chu/xu-lie-hua/"/>
      <url>2020/10/06/java-ji-chu/xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="什么时候需要将对象序列化？"><a href="#什么时候需要将对象序列化？" class="headerlink" title="什么时候需要将对象序列化？"></a>什么时候需要将对象序列化？</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><strong>序列化：</strong>将Java对象转换成字节流的过程</p><p><strong>反序列化：</strong>将字节流转换成Java对象的过程</p><p>为了保障在JVM停止运行后，能够保存对象的状态信息，即成员变量信息，持久化指定的对象，并在将来重新读取被保障的对象。</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><ul><li>当Java对象需要在网络中传输时</li><li>当Java对象需要持久化存储到文件中时</li><li>远程方法调用</li></ul><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><ul><li><p>只要类实现了Serializable接口（此接口实际上是没有方法的），此类就可以支持被序列化或者反序列化。</p></li><li><p>如果一个类想要被序列化，必须实现Serializable接口，否则将抛出<code>NotSerializableException</code>异常，这是因为在序列化操作的过程中，会对类型进行检查（在writeObject方法中），要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。</p></li><li><p>声明为<strong>static</strong>和<strong>transient</strong>的成员变量，不能被序列化，因此在变量中声明了此关键字，可以组织变量被序列化。</p></li></ul><p>这里需要说明的是ArrayList的<code>transient Object[] elementData</code>声明了<strong>transient</strong>，但是实际上ArrayList依然可以被序列化，这是因为对象的序列化过程实质是通过ObjectOutputStream和ObjectInputputStream来实现，其利用反射的方式调用writeObjectMethod方法，来对ArrayList的元素进行序列化。</p><p><strong>为什么不直接对ArrayList序列化呢？</strong></p><p>ArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。这样可以防止一个包含大量空对象的数组被序列化，达到优化存储的效果。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer11-旋转数组的最小数字</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/er-fen/jian-zhi-offer11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/er-fen/jian-zhi-offer11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer11-旋转数组的最小数字Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#剑指offer11-旋转数组的最小数字Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="剑指offer11-旋转数组的最小数字Find Minimum in Rotated Sorted Array II"></a>剑指offer11-旋转数组的最小数字<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">Find Minimum in Rotated Sorted Array II</a></h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p><pre><code>Example 1:Input: [1,3,5]Output: 1Example 2:Input: [2,2,2,0,1]Output: 0</code></pre><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>二叉树的最大高度，是由其左子树最大高度和右子树的最大高度中取最大值 + 根节点高度 1 计算出来的</li><li>时间复杂度：*<em>O(n)**</em>，空间复杂度：<strong>O(1)</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/bubblesort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/bubblesort/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="1-什么是冒泡排序？"><a href="#1-什么是冒泡排序？" class="headerlink" title="1. 什么是冒泡排序？"></a>1. 什么是冒泡排序？</h2><p>冒泡算法顾名思义就是重复地遍历数组中的元素，每次比较两个元素，如果顺序错误就交换位置，接着再比较下一对相邻元素直到最后一个元素确定为最值，接着再重新遍历比较除了有序元素的数组元素。</p><ul><li><strong>从数组末尾位置开始确定排好序的元素，一般为升序，即每次确定最大值放在末位。</strong></li><li>关注点是最大值</li></ul><h2 id="2-代码思路"><a href="#2-代码思路" class="headerlink" title="2. 代码思路"></a>2. 代码思路</h2><ol><li>鲁棒性检查，如果数组为空或者长度小于2直接返回</li><li>因为是从最末位位置开始确定元素，所以从<strong>“末位-&gt;0”</strong>先固定n-1、n-2、n-3、…0位置的元素，固定好后末位依次减1</li><li>在<strong>“末位-0”</strong>范围内，从0位置开始遍历数组并比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个</li></ol><h2 id="3-时间复杂度-amp-空间复杂度"><a href="#3-时间复杂度-amp-空间复杂度" class="headerlink" title="3. 时间复杂度 &amp; 空间复杂度"></a>3. 时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：总共O(N)，额外空间复杂度O(1)</li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//鲁棒性判断</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> end<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="2020/10/05/java-ji-chu/string/"/>
      <url>2020/10/05/java-ji-chu/string/</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="1-字符串为什么不可变"><a href="#1-字符串为什么不可变" class="headerlink" title="1. 字符串为什么不可变"></a>1. 字符串为什么不可变</h2><p>因为String被定义为final，初始化定义String的数组不能再引用其他数组，并且String内部没有改变数组中元素的方法，因此String是不可变的。</p><p><strong>java8对Stirng的定义：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>         <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><strong>java9对Stirng的定义：</strong>String 类的实现改用 byte 数组存储字符串，同时使用coder来标识编码类型</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>缓存hash值</strong>：String用作hashmap的key，不可变的特性可以使同样的key的hash值保持不变，使得hashmap只需要一次计算即可得到对应的k-v。</p></li><li><p><strong>满足字符串常量池的需要</strong>：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可使用 String Pool。</p></li><li><p><strong>安全性</strong>：String 作为参数，String 不可变性可以保证参数不可变。比如在网络连接中，如果同一个的连接中，如果String参数是可变的，那么会误认为连接方发生了改变。</p></li><li><p><strong>线程安全</strong>：因为String 中的对象是不可变的，也就可以理解为常量，所以线程安全。</p></li></ul><h2 id="2-String-和-StringBuﬀer、StringBuilder-的区别是什么？"><a href="#2-String-和-StringBuﬀer、StringBuilder-的区别是什么？" class="headerlink" title="2. String 和 StringBuﬀer、StringBuilder 的区别是什么？"></a>2. String 和 StringBuﬀer、StringBuilder 的区别是什么？</h2><p>StringBuilder 与 StringBuﬀer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[]value 但是没有用 ﬁnal 关键字修饰，StringBuilder 与 StringBuﬀer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，所以这两种对象都是可变的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>       <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>       <span class="token keyword">int</span> count<span class="token punctuation">;</span>       <span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>       <span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>线程安全：</strong></p><ul><li>StringBuﬀer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对方法加同步锁，所以是非线程安全的。</li><li>String可以理解为常量，所以线程安全。</li></ul><p><strong>三者使用的总结：</strong></p><ol><li><p>操作少量的数据 = String</p></li><li><p>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</p></li><li><p>多线程操作字符串缓冲区下操作大量数据 = StringBuﬀer</p></li></ol><h1 id="3-String-ValueOf和toString区别"><a href="#3-String-ValueOf和toString区别" class="headerlink" title="3. String.ValueOf和toString区别"></a>3. String.ValueOf和toString区别</h1><p>将对象转换成String类型常用的有如下三种方式：</p><ul><li>(String)[对象]</li><li>[对象].toString</li><li>String.valueOf([对象])</li></ul><p><strong>(String)</strong></p><p>这是标准的类型转换，将对象强制转换为String类型，前提是<strong>该对象必须能保证转成String类型</strong>，否则将抛出ClassCastException异常。</p><p><strong>toString</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** This object (which is already a string!) is itself returned.** @return  the string itself.*/</span><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678</span></code></pre><p>此方法返回对象本身，在java.lang.Object类中也有toString()方法，所以Java对象都可以调用此方法，但使用的时候<strong>必须保证要转换的对象不为null</strong>，否则将抛出NullPointerException异常。</p><p><strong>String.valueOf()</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** Returns the string representation of the &lt;code>Object&lt;/code> argument.** @param   obj   an &lt;code>Object&lt;/code>.* @return  if the argument is &lt;code>null&lt;/code>, then a string equal to*          &lt;code>"null"&lt;/code>; otherwise, the value of*          &lt;code>obj.toString()&lt;/code> is returned.* @see     java.lang.Object#toString()*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">valueOf</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"null"</span> <span class="token operator">:</span> obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从上面源码可以看出，可以不用担心Object为null，但使用的时候也要小心，<strong>当Object为null时，它的返回值是“null”，而不是null</strong>，这是有区别的。</p><h2 id="String有长度限制吗？"><a href="#String有长度限制吗？" class="headerlink" title="String有长度限制吗？"></a>String有长度限制吗？</h2><p>字符串有长度限制，在编译期，要求字符串常量池中的常量不能超过65535(2^16 - 1)，并且在javac执行过程中控制了最大值为65534。</p><p>在运行期，长度不能超过Int的范围，否则会抛异常，因为在其构造函数中，有对Stirng类型的长度的定义：<code>public String(byte bytes[], int offset, int length) </code>根据Integer类的定义，<code>java.lang.Integer#MAX_VALUE</code>的最大值是2^31 - 1。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动拆装箱</title>
      <link href="2020/10/05/java-ji-chu/zi-dong-chai-zhuang-xiang/"/>
      <url>2020/10/05/java-ji-chu/zi-dong-chai-zhuang-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h1><h2 id="什么是包装类型和基本类型，以及自动拆装箱"><a href="#什么是包装类型和基本类型，以及自动拆装箱" class="headerlink" title="什么是包装类型和基本类型，以及自动拆装箱"></a>什么是包装类型和基本类型，以及自动拆装箱</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><ul><li>装箱：自动装箱就是Java自动将原始基本类型值转换成对应的对象，比如将int的变量转换成Integer对象，编译器通过调用valueOf将原始类型值转换成对象</li><li>拆箱：反之将对象转换成基本类型值，比如Integer对象转换成int类型值，编译器通过调用类似intValue()，doubleValue()这类的方法将对象转换成原始类型值</li><li>自动装箱是将boolean值转换成Boolean对象，byte值转换成Byte对象，char转换成Character对象，float值转换成Float对象，int转换成Integer，long转换成Long，short转换成Short，自动拆箱则是相反的操作</li></ul><pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//装箱</span><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拆箱</span></code></pre><h2 id="Integer-的缓存机制"><a href="#Integer-的缓存机制" class="headerlink" title="Integer 的缓存机制"></a>Integer 的缓存机制</h2><p>在调用Integer.valueOf()方法时，Integer封装类型会先判断方法想要的值是否在缓存池中，如果在的话就直接返回缓存池的内容，不在的话就创建一个新的Integer对象。</p><p><strong>在 Java 8 中，Integer 缓存池的大小默认为 -128~127</strong>，上界可通过jvm参数进行调整</p><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false </li><li>all byte values </li><li>short values between -128 and 127 </li><li>int values between -128 and 127 </li><li>char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么说Java是值传递</title>
      <link href="2020/10/05/java-ji-chu/wei-shi-me-shuo-java-shi-zhi-chuan-di/"/>
      <url>2020/10/05/java-ji-chu/wei-shi-me-shuo-java-shi-zhi-chuan-di/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么说-Java-中只有值传递"><a href="#为什么说-Java-中只有值传递" class="headerlink" title="为什么说 Java 中只有值传递"></a>为什么说 Java 中只有值传递</h1><ul><li><strong>值传递</strong>（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li></ul><ul><li><strong>引用传递</strong>（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><p><strong>对于对象参数，值的内容是对象的引用</strong>，简单点说Java中的传递是值传递，而这个值，实际上是对象的引用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="2020/10/05/java-ji-chu/ji-ben-shu-ju-lei-xing/"/>
      <url>2020/10/05/java-ji-chu/ji-ben-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="8-种基本数据类型：整型、浮点型、布尔型、字符型"><a href="#8-种基本数据类型：整型、浮点型、布尔型、字符型" class="headerlink" title="8 种基本数据类型：整型、浮点型、布尔型、字符型"></a>8 种基本数据类型：整型、浮点型、布尔型、字符型</h2><ul><li>byte/8bit </li><li>char/16bit  </li><li>short/16bit  </li><li>int/32bit  </li><li>ﬂoat/32bit  </li><li>long/64bit  </li><li>double/64bit  </li><li>boolean/~</li></ul><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p><h2 id="什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？"><a href="#什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？" class="headerlink" title="什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？"></a>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</h2><p>浮点型简单来说就是表示带有小数的数据</p><p>单精度<code>float</code>、双精度<code>double</code></p><ul><li>单精度浮点数在机内占<code>4</code>个字节、有效数字<code>8</code>位、表示范围：<code>-3.40E+38 ~ +3.40E+38</code></li><li>双精度浮点数在机内占<code>8</code>个字节、有效数字<code>16</code>位、表示范围：<code>-1.79E+308 ~ +1.79E+308</code></li></ul><p>Java默认把小数当做<code>double</code>类型来处理，要想该字面值当做<code>float</code>类型来处理，需要在字面值后面添加<code>F/f</code>,或者强制装换为<code>float</code></p><p>财务涉及到钱的问题，要求精度较高，所以在java中有一个基础的类库名为：<code>java.math.BigDecimal</code>，但这个<code>BigDecimal</code>类型是<strong>引用类型</strong>不是基础类型</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/heapsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/heapsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是堆排序？"><a href="#什么是堆排序？" class="headerlink" title="什么是堆排序？"></a>什么是堆排序？</h2><ol><li><strong>heapinsert:</strong> 先把数组变成大根堆或者小根堆</li><li>把堆顶的元素放到数组最末位，并且固定，即不再扫描，size–</li><li><strong>heapify：</strong>维护当前堆大小范围内的为小根堆或者大根堆</li><li>循环2、3步，直到size为0</li></ol><h4 id="heapinsert（产生大根堆或者小根堆）"><a href="#heapinsert（产生大根堆或者小根堆）" class="headerlink" title="heapinsert（产生大根堆或者小根堆）"></a>heapinsert（产生大根堆或者小根堆）</h4><ul><li><strong>(大根堆)**比较：如果当前位置元素比父亲节点元素值</strong>大**，就交换，当前位置挪向父亲节点索引值，再次重复，直到当前位置元素值不大于父亲节点的值</li><li><strong>(小根堆)**比较：如果当前位置元素比父亲节点元素值</strong>小**，就交换，当前位置挪向父亲节点索引值，再次重复，直到当前位置元素值不大于父亲节点的值</li></ul><h4 id="heapify（在0-size-1范围内维护大根堆或者小根堆）"><a href="#heapify（在0-size-1范围内维护大根堆或者小根堆）" class="headerlink" title="heapify（在0~size-1范围内维护大根堆或者小根堆）"></a>heapify（在0~size-1范围内维护大根堆或者小根堆）</h4><ul><li>在当前位置有孩子情况下，判断左右两个孩子大小</li><li>将孩子中较大的和父亲比</li><li>如果这个孩子比父亲大，那孩子和父亲交换位置</li><li>继续向下扫描直到这个节点到达属于它应该的位置，即它比它的孩子都大</li></ul><p>（实际上是在判断当前的这个节点是不是称职的父亲，即它的值要比它的孩子都大）</p><p><em>Note：</em></p><ul><li>父节点 = （index - 1）/ 2</li><li>子节点（左） = （index * 2）+ 1</li><li>子节点（左） = （index * 2）+ 2</li></ul><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_03_HeapSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> largest <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>            largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> largest<span class="token punctuation">;</span>            left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/incertsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/incertsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是插入排序？"><a href="#什么是插入排序？" class="headerlink" title="什么是插入排序？"></a>什么是插入排序？</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><ul><li><strong>从数组首位开始确定排好序的元素，一般为升序，即每次确定最小值放在首位</strong></li><li>关注点是最小值</li></ul><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N^2)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：O(N)total，O(1)auxiliary</li></ul><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//长度大于2的，从位置1开始遍历比较</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/quicksort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/quicksort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是快速排序？"><a href="#什么是快速排序？" class="headerlink" title="什么是快速排序？"></a>什么是快速排序？</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(NlogN)</li><li>平均时间复杂度：O(NlogN)</li><li>空间复杂度：O(logN) (递归方式)</li></ul><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> less <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> more <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> more<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>less<span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">--</span>more<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> more<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> less <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> more <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/mergesort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/mergesort/</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java">            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p1 <span class="token operator">=</span> left<span class="token punctuation">,</span> p2<span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/selectsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/selectsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是选择排序？"><a href="#什么是选择排序？" class="headerlink" title="什么是选择排序？"></a>什么是选择排序？</h2><p>首先在数组中找最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><ul><li><strong>从数组首位开始确定排好序的元素，一般为升序，即每次确定最小值放在首位</strong></li><li>关注点是最小值</li></ul><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ol><li>从数组首位开始遍历</li><li>定义minIndex（最小值索引）</li><li>遍历比较，找到当前范围minIndex，（比较范围是未排序元素数组范围）</li><li>交换，将当前最小值依次放在数组最左边</li></ol><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N^2)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：O(N)total，O(1)auxiliary</li></ul><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">?</span> j <span class="token operator">:</span> minIndex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer55-二叉树的深度</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer55-er-cha-shu-de-shen-du/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer55-er-cha-shu-de-shen-du/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer55-二叉树的深度Maximum-Depth-of-Binary-Tree"><a href="#剑指offer55-二叉树的深度Maximum-Depth-of-Binary-Tree" class="headerlink" title="剑指offer55-二叉树的深度Maximum Depth of Binary Tree"></a>剑指offer55-二叉树的深度<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree</a></h1><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>Note: A leaf is a node with no children.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>二叉树的最大高度，是由其左子树最大高度和右子树的最大高度中取最大值 + 根节点高度 1 计算出来的</li><li>时间复杂度：*<em>O(n)**</em>，空间复杂度：<strong>O(1)</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer54-二叉搜索树的第k大值</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer54-er-cha-sou-suo-shu-de-di-k-da-zhi/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer54-er-cha-sou-suo-shu-de-di-k-da-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer54-二叉搜索树的第k大值"><a href="#剑指offer54-二叉搜索树的第k大值" class="headerlink" title="剑指offer54-二叉搜索树的第k大值"></a>剑指offer54-二叉搜索树的第k大值</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义全局变量以便返回结果</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> res<span class="token punctuation">,</span> countk<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        countk <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//按“右中左”遍历二叉搜索树，遍历到第k个点即为第k大的点</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>countk <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countk<span class="token operator">--</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>首先明确二叉搜索树的特征<ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li><strong>没有键值相等的节点</strong></li></ul></li><li>二叉搜索树的节点按<strong>中序遍历</strong>（左中右）正好可以构成递增节点序列</li><li>题目要找到第 k 大的节点，所以需要数字降序排列，则将中序遍历按照右、中、左遍历即可，遍历的同时找到第 k 个遍历到的值</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer27-二叉树镜像</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer27-er-cha-shu-jing-xiang/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer27-er-cha-shu-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer27-二叉树镜像-Invert-Binary-Tree"><a href="#剑指offer27-二叉树镜像-Invert-Binary-Tree" class="headerlink" title="剑指offer27-二叉树镜像 Invert Binary Tree"></a>剑指offer27-二叉树镜像<a href="https://leetcode-cn.com/problems/invert-binary-tree/"> Invert Binary Tree</a></h1><p>Invert a binary tree.</p><p>Example:</p><p>Input:</p><pre><code>     4   /   \  2     7 / \   / \1   3 6   9</code></pre><p>Output:</p><pre><code>     4   /   \  7     2 / \   / \9   6 3   1</code></pre><h2 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h2><p>此题并没有要求在原来二叉树的基础上调整二叉树为镜像，也就是说对空间复杂度没有限制，因此可以通过创建节点，根据深度优先策略来创建此二叉树的镜像。时间复杂度可以达到O(n)，但是空间复杂度是以O(n)为代价的。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode res <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//深度优先策略，通过递归的方式遍历二叉树的节点</span>            res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="2020/10/01/shu-ju-ku/shu-ju-ku-shi-wu/"/>
      <url>2020/10/01/shu-ju-ku/shu-ju-ku-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
