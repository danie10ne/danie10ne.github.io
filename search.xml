<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>29. 顺时针打印矩阵</title>
      <link href="2020/10/13/shu-ju-jie-gou-yu-suan-fa/shu-zu/da-yin-ju-zhen/"/>
      <url>2020/10/13/shu-ju-jie-gou-yu-suan-fa/shu-zu/da-yin-ju-zhen/</url>
      
        <content type="html"><![CDATA[<h3 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h3><ul><li>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</li></ul><p>示例 1：</p><pre><code>   输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]   输出：[1,2,3,6,9,8,7,4,5]</code></pre><p>示例 2：</p><pre><code>   输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]   输出：[1,2,3,4,8,12,11,10,9,5,6,7]</code></pre><p>限制：</p><pre><code>   0 &lt;= matrix.length &lt;= 100   0 &lt;= matrix[i].length &lt;= 100</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>将顺时针打印问题转换成从外圈到内圈打印矩阵</li><li>打印一个矩阵的边，从左上角第一个元素到右上角最后一个元素；再从右上角最后一个元素到右下脚最后一个元素；从右下角最后一个元素到左下角第一个元素；从左下角第一个元素到左上角第一个元素，完成一个矩阵的打印</li><li>有两个特殊情况：<ul><li>矩阵只是单独一行：从左至右打印</li><li>矩阵只有单独一列：从上到下打印</li></ul></li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">spiralOrder</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length <span class="token operator">*</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dr <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> dc <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>tr <span class="token operator">&lt;=</span> dr <span class="token operator">&amp;&amp;</span> tc <span class="token operator">&lt;=</span> dc<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token function">printEdge</span><span class="token punctuation">(</span>matrix<span class="token punctuation">,</span> tr<span class="token operator">++</span><span class="token punctuation">,</span> tc<span class="token operator">++</span><span class="token punctuation">,</span> dr<span class="token operator">--</span><span class="token punctuation">,</span> dc<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> tr<span class="token punctuation">,</span> <span class="token keyword">int</span> tc<span class="token punctuation">,</span> <span class="token keyword">int</span> dr<span class="token punctuation">,</span> <span class="token keyword">int</span> dc<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//矩阵为只有一行的情况  </span>      <span class="token keyword">if</span><span class="token punctuation">(</span>tr <span class="token operator">==</span> dr<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur <span class="token operator">=</span> tc<span class="token punctuation">;</span> cur <span class="token operator">&lt;=</span> dc<span class="token punctuation">;</span> cur<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>tr<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>tc <span class="token operator">==</span> dc<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//矩阵为只有一列的情况 </span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> cur <span class="token operator">=</span> tr<span class="token punctuation">;</span> cur <span class="token operator">&lt;=</span> dr<span class="token punctuation">;</span> cur<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> curC <span class="token operator">=</span> tc<span class="token punctuation">;</span>            <span class="token keyword">int</span> curR <span class="token operator">=</span> tr<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//因为是顺时针所以先从左往右从上到下打印</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>curC <span class="token operator">!=</span> dc<span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>tr<span class="token punctuation">]</span><span class="token punctuation">[</span>curC<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                curC<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>curR <span class="token operator">!=</span> dr<span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>curR<span class="token punctuation">]</span><span class="token punctuation">[</span>dc<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                curR<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>curC <span class="token operator">!=</span> tc<span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>dr<span class="token punctuation">]</span><span class="token punctuation">[</span>curC<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                curC<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>curR <span class="token operator">!=</span> tr<span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>curR<span class="token punctuation">]</span><span class="token punctuation">[</span>tc<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                curR<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM自动内存管理机制</title>
      <link href="2020/10/12/jvm/jvm-zi-dong-nei-cun-guan-li-ji-zhi/"/>
      <url>2020/10/12/jvm/jvm-zi-dong-nei-cun-guan-li-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM自动内存管理机制"><a href="#JVM自动内存管理机制" class="headerlink" title="JVM自动内存管理机制"></a>JVM自动内存管理机制</h1><h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>——内存中放了些什么？</p><blockquote><p>Java虚拟机在执行Java程序时把所管理的内存划分为不同区域，各行其则。</p></blockquote><h3 id="1-程序计数器（线程私有）"><a href="#1-程序计数器（线程私有）" class="headerlink" title="1. 程序计数器（线程私有）"></a>1. 程序计数器（线程私有）</h3><ul><li>当前线程所执行的字节码的行号指示器，字节码解释器通过改变计数器的值选取需要执行的字节码指令</li><li>每个线程都有一个独立的程序计数器，得到一个“线程私有”的内存</li></ul><p><strong>执行Java方法：</strong>计数器记录正在执行的虚拟机字节码指令地址<br><strong>执行Native方法：</strong>计数器的值为空（Undefined），且此内存区域是Java虚拟机中没有OutOfMemoryError情况的区域</p><h3 id="2-Java虚拟机栈（线程私有）"><a href="#2-Java虚拟机栈（线程私有）" class="headerlink" title="2. Java虚拟机栈（线程私有）"></a>2. Java虚拟机栈（线程私有）</h3><ul><li>虚拟机栈描述的是Java方法执行的内存模型</li><li>每个方法执行对应一个栈帧，方法从调用到执行的过程，就是栈帧在虚拟机栈中入栈到出栈的过程</li><li>栈是虚拟机站中的局部变量表，其存放了编译期的基本数据类型、对象引用，方法运行时在帧中分配的局部变量空间是完全确定的</li></ul><p><strong>异常</strong><br><em>StackOverflowError</em>: 线程请求的栈深度大于虚拟机所允许的深度<br><em>OutOfMemoryError</em>: 虚拟机栈动态扩展时无法申请到足够的内存</p><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><ul><li>本地方法栈为虚拟机提供Native方法服务</li></ul><p><strong>异常</strong><br><em>StackOverflowError</em>: 线程请求的栈深度大于虚拟机所允许的深度<br><em>OutOfMemoryError</em>: 虚拟机栈动态扩展时无法申请到足够的内存</p><h3 id="4-Java堆"><a href="#4-Java堆" class="headerlink" title="4. Java堆"></a>4. Java堆</h3><ul><li>所有线程共享，在虚拟机启动时创建</li><li><strong>目的：</strong>存放对象实例</li><li>是垃圾收集器管理的主要区域（GC堆）</li><li>Java堆只要逻辑上连续即可，虚拟机可通过-Xmx和-Xms动态扩展堆空间</li></ul><p><strong>异常</strong><br><em>OutOfMemoryError</em>:如果堆中没有内存完成实例分配，且堆无法再扩展</p><h3 id="5-方法区（Non-Heap）"><a href="#5-方法区（Non-Heap）" class="headerlink" title="5. 方法区（Non-Heap）"></a>5. 方法区（Non-Heap）</h3><ul><li><strong>目的：</strong>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li></ul><p><strong>异常</strong><br><em>OutOfMemoryError</em>: 方法区无法满足内存分配需求时抛出</p><h3 id="6-运行时常量池"><a href="#6-运行时常量池" class="headerlink" title="6. 运行时常量池"></a>6. 运行时常量池</h3><ul><li>是方法区的一部分</li><li>存放编译期生成的字面量和符号引用以及翻译出来的直接引用</li><li>具有动态性，可动态的存储Class文件中常量池中新的内容</li></ul><p><strong>异常</strong><br><em>OutOfMemoryError</em>: 常量池无法再申请到内存时抛出</p><h3 id="7-直接内存"><a href="#7-直接内存" class="headerlink" title="7. 直接内存"></a>7. 直接内存</h3><blockquote><p>直接内存并不属于运行时数据区和Java虚拟机规范内存区域，但会被频繁使用</p></blockquote><ul><li>NIO(New Input/Output)类，引入了基于通道与缓冲区的I/O方式，使Native函数库直接分配到堆外内存，利用Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样可以避免Java堆和Native堆中来回复制数据，从而显著提高性能。</li></ul><p><img src="https://i.loli.net/2020/10/12/PmECbo7WsLwaS4t.png" alt="Screen Shot 2020-10-12 at 10.43.44 PM.png"></p><h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><p>——内存中数据运用的细节</p><h3 id="1-对象的创建及初始化过程"><a href="#1-对象的创建及初始化过程" class="headerlink" title="1. 对象的创建及初始化过程"></a>1. 对象的创建及初始化过程</h3><h4 id="1-new指令创建对象"><a href="#1-new指令创建对象" class="headerlink" title="1) new指令创建对象"></a>1) new指令创建对象</h4><h4 id="2-类加载检查"><a href="#2-类加载检查" class="headerlink" title="2) 类加载检查"></a>2) 类加载检查</h4><ul><li>首先检查指令的参数是否在常量池中定位到一个类的符号引用</li><li>检查符号引用是否被加载、解析、初始化</li><li>如果没有加载，先进行类加载过程</li></ul><h4 id="3）分配内存"><a href="#3）分配内存" class="headerlink" title="3）分配内存"></a>3）分配内存</h4><blockquote><p>类加载完成后，虚拟机将为新生对象从Java堆中分配内存，且大小在加载完成后完全确定</p></blockquote><ul><li><strong>指针碰撞（堆内存绝对规整）</strong>：空闲内存和已使用内存以指针为分界，分配内存时，指针向空闲空间挪动需要分配内存大小的距离</li><li><strong>空闲列表（堆内存不规整）</strong>：虚拟机维护一个内存空间使用情况列表，分配内存时，更新列表数据</li></ul><h6 id="并发问题的解决"><a href="#并发问题的解决" class="headerlink" title="并发问题的解决"></a>并发问题的解决</h6><ul><li>对分配内存空间的动作进行同步处理，采用CAS+失败重试机制</li><li><strong>TLAB(本地线程分配缓冲Thread Local Allocation Buffer)</strong>: 每个线程预先分配一块内存，只有TLAB用完并分配新的TLAB时，才同步锁定</li></ul><h4 id="4）内存空间初始化"><a href="#4）内存空间初始化" class="headerlink" title="4）内存空间初始化"></a>4）内存空间初始化</h4><ul><li>内存空间分配完成后，虚拟机将其初始化为零值（如果使用TLAB,在分配TLAB时就会进行）。从而保证对象的实例字段在Java代码中可以不赋初始值就直接使用。</li></ul><h4 id="5）配置对象信息"><a href="#5）配置对象信息" class="headerlink" title="5）配置对象信息"></a>5）配置对象信息</h4><ul><li>虚拟机根据对象头的信息对对象进行必要的设置，比如哪个类的实例、类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。</li></ul><h4 id="6）执行方法"><a href="#6）执行方法" class="headerlink" title="6）执行方法"></a>6）执行方法</h4><ul><li>执行new指令后，虚拟机接着会执行方法，把对象按照程序员的意愿进行初始化，至此一个对象创建完成。</li></ul><p><img src="https://i.loli.net/2020/10/12/M3KlwvEWfQpUXLF.png" alt="Screen Shot 2020-10-12 at 10.44.46 PM.png"></p><h3 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h3><blockquote><p>对象在内存中存储的布局分为：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</p></blockquote><h4 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1) 对象头"></a>1) 对象头</h4><ul><li><strong>Mark Word</strong>：对象头第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。Mark Word采用非固定的数据结构，以便存储尽量多的信息。</li><li><strong>类型指针</strong>：对象头的另外一部分，是对象指向它的类元数据的指针，虚拟机通过这个指针确定对象属于哪个类的实例。</li></ul><p>note：因为虚拟机无法从数组的元数据中确定数组的大小，因此如果对象是Java数组，对象头还必须包含一块用于记录数组长度的数据。</p><h4 id="2）实例数据"><a href="#2）实例数据" class="headerlink" title="2）实例数据"></a>2）实例数据</h4><blockquote><p>代码中定义的各种字段内容，需要考虑存储顺序</p></blockquote><ul><li>相同宽度字段分配到一起</li><li>在上一条前提下，父类定义变量在子类变量之前</li><li>如果CompactFields为true，子类中较窄的变量会插入到父类变量的空隙中</li></ul><h4 id="3）对齐填充"><a href="#3）对齐填充" class="headerlink" title="3）对齐填充"></a>3）对齐填充</h4><blockquote><p>起着占位符的作用</p></blockquote><ul><li>HotSpot要求对象的大小必须是8字节的整数倍，通过对齐填充补全，使对象大小为8的整数倍</li></ul><h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h3><blockquote><p>栈上的reference规定了一个指向对象的引用，没有定义定位方式和对象具体位置，由虚拟机本身决定</p></blockquote><h4 id="1）句柄"><a href="#1）句柄" class="headerlink" title="1）句柄"></a>1）句柄</h4><ul><li>句柄包含对象实例数据与类型数据各自的地址信息，堆中划分一块内存作为句柄池，reference存储对象的句柄地址</li><li><strong>优点：</strong>reference存储的是稳定的句柄地址，对象移动只会改变句柄中的实例数据指针，不会改变reference本身的数据</li></ul><p><img src="https://i.loli.net/2020/10/12/sMxhGSjI6qAaoYP.png" alt="Screen Shot 2020-10-12 at 10.45.42 PM.png"></p><h4 id="2）直接指针"><a href="#2）直接指针" class="headerlink" title="2）直接指针"></a>2）直接指针</h4><ul><li>reference存储对象地址，堆中存储访问类型数据的相关信息</li><li><strong>优点：</strong>速度更快，节省了指针定位的时间开销，HotSpot采用此方式访问对象</li></ul><p><img src="https://i.loli.net/2020/10/12/mj583SHMCowiJOf.png" alt="Screen Shot 2020-10-12 at 10.46.38 PM.png"></p><h1 id="异常分析"><a href="#异常分析" class="headerlink" title="异常分析"></a>异常分析</h1><h3 id="1-Java堆溢出"><a href="#1-Java堆溢出" class="headerlink" title="1. Java堆溢出"></a>1. Java堆溢出</h3><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p><em>OutOfMemoryError</em>: 对象数量达到最大堆的容量限制且GC Roots到对象之间有可达路径避免垃圾回收机制清除对象</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul><li>确认内存中对象是否必要</li><li>确认是内存泄漏(Memory Leak)还是内存溢出（Memory Overflow）</li></ul><p><strong>1）内存泄漏</strong></p><p>查看泄漏对象到GC Root的引用链，从而找到泄漏对象通过怎样的路径与GC Root相关联并导致垃圾收集器无法自动回收它们，接着可以定位具体泄漏代码的位置。</p><p><strong>2）内存溢出</strong></p><p>检查虚拟机的堆参数（-Xmx和-Xms），与机器物理内存对比看是否还能调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p><h3 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2. 虚拟机栈和本地方法栈溢出"></a>2. 虚拟机栈和本地方法栈溢出</h3><h5 id="异常-1"><a href="#异常-1" class="headerlink" title="异常"></a>异常</h5><p><em>StackOverflowError</em>: 线程请求的栈深度大于虚拟机所允许的深度<br><em>OutOfMemoryError</em>: 虚拟机栈动态扩展时无法申请到足够的内存</p><p><strong>note</strong></p><p>单线程下，无论栈帧太大还是虚拟机栈容量太小，内存无法分配时，都抛出StackOverflowError异常</p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p><strong>1）StackOverflowError</strong>：阅读错误堆栈，找到出错位置</p><p><strong>2）StackOverflowError</strong>：多线程内存溢出，考虑减少最大堆和减少栈容量来换取更多的线程（前提不能减少线程数或者更换64位虚拟机）</p><h3 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3. 方法区和运行时常量池溢出"></a>3. 方法区和运行时常量池溢出</h3><p>方法区存放Class相关信息，如类名、访问修饰符、常量池、字段描述方法描述等，基本思路是运行时产生大量的类填满方法区，直到溢出。</p><h3 id="4-本机直接内存溢出"><a href="#4-本机直接内存溢出" class="headerlink" title="4. 本机直接内存溢出"></a>4. 本机直接内存溢出</h3><p>由DirectMemory导致的内存溢出，是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，程序中使用了NIO，就可以考虑是直接内存溢出了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I. 二叉搜索树的最近公共祖先</title>
      <link href="2020/10/12/shu-ju-jie-gou-yu-suan-fa/er-cha-shu/er-cha-shu-de-zui-jin-gong-gong-zu-xian-i/"/>
      <url>2020/10/12/shu-ju-jie-gou-yu-suan-fa/er-cha-shu/er-cha-shu-de-zui-jin-gong-gong-zu-xian-i/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-68-I-二叉搜索树的最近公共祖先"><a href="#剑指-Offer-68-I-二叉搜索树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"></a>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://i.loli.net/2020/10/12/x3JzhkaFYmPbGru.png" alt="Screen Shot 2020-10-12 at 9.14.05 PM.png"></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li><strong>最近公共祖先，通常表现为： p、q 节点不在最近公共祖先的同一个子树上</strong></li><li>树是二叉搜索树，所有的节点值唯一，则可以根据 p、q 节点不在最近公共祖先的同一个子树上的特征，进行循环遍历，找到结果。</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> main<span class="token punctuation">.</span>java<span class="token punctuation">.</span>com<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>space<span class="token punctuation">.</span>solution<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution68I</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        TreeNode left<span class="token punctuation">;</span>        TreeNode right<span class="token punctuation">;</span>        <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TreeNode <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//如果根节点都小于p、q说明p、q都在root的右子树上</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">&lt;</span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果根节点都大于p、q说明p、q都在root的左子树上</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val <span class="token operator">></span> p<span class="token punctuation">.</span>val <span class="token operator">&amp;&amp;</span> root<span class="token punctuation">.</span>val <span class="token operator">></span> q<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>                root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//包含：root.val == p.val，root.val == q.val，root.val > p.val &amp;&amp; root.val &lt; q.val 或者 root.val &lt; p.val &amp;&amp; root.val > q.val，</span>                <span class="token keyword">return</span> root<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I. 二叉搜索树的最近公共祖先</title>
      <link href="2020/10/12/shu-ju-jie-gou-yu-suan-fa/er-cha-shu/er-cha-shu-de-zui-jin-gong-gong-zu-xian-ii/"/>
      <url>2020/10/12/shu-ju-jie-gou-yu-suan-fa/er-cha-shu/er-cha-shu-de-zui-jin-gong-gong-zu-xian-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a>剑指 Offer 68 - II. 二叉树的最近公共祖先</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个<strong>二叉树</strong>, 找到该树中两个指定节点的最近公共祖先。</p><p>   百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>   例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>   <strong>递归解析：</strong></p><ol><li>终止条件：</li></ol><ul><li>当越过叶节点，则直接返回 nullnull ；</li><li>当 rootroot 等于 p, qp,q ，则直接返回 rootroot ；</li></ul><ol start="2"><li>递推工作：</li></ol><ul><li>开启递归左子节点，返回值记为 leftleft ；<br> *开启递归右子节点，返回值记为 rightright ；</li></ul><ol start="3"><li>返回值： 根据 leftleft 和 rightright ，可展开为四种情况；</li></ol><ul><li><p>当 leftleft 和 rightright 同时为空 ：说明 rootroot 的左 / 右子树中都不包含 p,qp,q ，返回 nullnull ；</p></li><li><p>当 leftleft 和 rightright 同时不为空 ：说明 p, qp,q 分列在 rootroot 的 异侧 （分别在 左 / 右子树），因此 rootroot 为最近公共祖先，返回 rootroot ；</p></li><li><p>当 leftleft 为空 ，rightright 不为空 ：p,qp,q 都不在 rootroot 的左子树中，直接返回 rightright 。</p><p>  具体可分为两种情况：</p><ul><li>p,qp,q 其中一个在 rootroot 的 右子树 中，此时 rightright 指向 pp（假设为 pp ）；</li><li>p,qp,q 两节点都在 rootroot 的 右子树 中，此时的 rightright 指向 最近公共祖先节点 ；</li></ul></li><li><p>当 leftleft 不为空 ， rightright 为空 ：与情况 3. 同理；</p></li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> main<span class="token punctuation">.</span>java<span class="token punctuation">.</span>com<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>space<span class="token punctuation">.</span>solution<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution68II</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        TreeNode left<span class="token punctuation">;</span>        TreeNode right<span class="token punctuation">;</span>        <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TreeNode <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> TreeNode p<span class="token punctuation">,</span> TreeNode q<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TreeNode left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        TreeNode right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> root<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>III. 从上到下打印二叉树</title>
      <link href="2020/10/11/shu-ju-jie-gou-yu-suan-fa/bfs/bfs3/"/>
      <url>2020/10/11/shu-ju-jie-gou-yu-suan-fa/bfs/bfs3/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-32-III-从上到下打印二叉树-III"><a href="#剑指-Offer-32-III-从上到下打印二叉树-III" class="headerlink" title="剑指 Offer 32 - III. 从上到下打印二叉树 III"></a>剑指 Offer 32 - III. 从上到下打印二叉树 III</h1><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>    3   / \  9  20    /  \   15   7返回其层次遍历结果：[  [3],  [20,9],  [15,7]]</code></pre><p>提示：</p><p>节点总数 &lt;= 1000</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//如果将要添加元素的层为奇数层，则进行尾插法，将结果按顺序在 list 尾部进行插入</span>                <span class="token comment" spellcheck="true">//如果将要添加元素的层为偶数层，则进行头插法，将结果按顺序在 list 头部进行插入</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>II.从上到下打印二叉树</title>
      <link href="2020/10/11/shu-ju-jie-gou-yu-suan-fa/bfs/bfs2/"/>
      <url>2020/10/11/shu-ju-jie-gou-yu-suan-fa/bfs/bfs2/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="#剑指-Offer-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指 Offer 32 - II. 从上到下打印二叉树 II"></a>剑指 Offer 32 - II. 从上到下打印二叉树 II</h1><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>    3   / \  9  20    /  \   15   7返回其层次遍历结果：[  [3],  [9,20],  [15,7]]</code></pre><p>提示：</p><p>节点总数 &lt;= 1000</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> level <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                level<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I.从上到下打印二叉树</title>
      <link href="2020/10/11/shu-ju-jie-gou-yu-suan-fa/bfs/bfs1/"/>
      <url>2020/10/11/shu-ju-jie-gou-yu-suan-fa/bfs/bfs1/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指-Offer-32-I-从上到下打印二叉树"><a href="#剑指-Offer-32-I-从上到下打印二叉树" class="headerlink" title="剑指 Offer 32 - I. 从上到下打印二叉树"></a>剑指 Offer 32 - I. 从上到下打印二叉树</h1><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p><p>例如:<br>给定二叉树: [3,9,20,null,null,15,7],</p><pre><code>    3   / \  9  20    /  \   15   7返回：[3,9,20,15,7]</code></pre><p>提示：</p><p>节点总数 &lt;= 1000</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        LinkedList<span class="token operator">&lt;</span>TreeNode<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ArrayList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//如果有左子树，将左子树的节点加入队列</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>滑动窗口的最大值</title>
      <link href="2020/10/11/shu-ju-jie-gou-yu-suan-fa/dui-lie/hua-dong-chuang-kou-de-zui-da-zhi/"/>
      <url>2020/10/11/shu-ju-jie-gou-yu-suan-fa/dui-lie/hua-dong-chuang-kou-de-zui-da-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动窗口的最大值Sliding-Window-Maximum"><a href="#滑动窗口的最大值Sliding-Window-Maximum" class="headerlink" title="滑动窗口的最大值Sliding Window Maximum"></a>滑动窗口的最大值<a href="https://leetcode-cn.com/problems/sliding-window-maximum/">Sliding Window Maximum</a></h1><p>给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。</p><p>示例:</p><pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释:   滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><p>提示：</p><p>你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> main<span class="token punctuation">.</span>java<span class="token punctuation">.</span>com<span class="token punctuation">.</span>algorithm<span class="token punctuation">.</span>space<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>LinkedList<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 1. 滑动窗口产生的结果数组大小为 nums.length - k + 1 * 2. 创建一个双端队列，并维护其单调递减性，来实现符合能求最大值的滑动窗口，注意这里队列中的元素是数组的索引 * 3. 然后判断滑动窗口的队首是否过期，每一轮遍历过期的索引为i-k，当队首索引等于i-k说明队首已经过期 * 4. 最后判断遍历的位置是否已经开始可以计入最大值，当遍历位置从k-1开始记录窗口最大值 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">maxSlidingWindow</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">maxSlidingWindow</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> k <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建一个长度为k的双端队列作为滑动窗口</span>        LinkedList<span class="token operator">&lt;</span>Integer<span class="token operator">></span> queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//维护滑动窗口，保持其是单调递减的</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>queue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>queue<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            queue<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//判断滑动窗口的头节点有没有过期，</span>            <span class="token comment" spellcheck="true">//当窗口队首等于当前遍历元素的索引与窗口大小的差值说明，窗口队首已过期</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>i<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//判断是否已经遍历到可以取最大值的位置，从i >= w-1开始</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">>=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>queue<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由两个栈组成的队列</title>
      <link href="2020/10/09/shu-ju-jie-gou-yu-suan-fa/zhan/you-liang-ge-zhan-zu-cheng-de-dui-lie/"/>
      <url>2020/10/09/shu-ju-jie-gou-yu-suan-fa/zhan/you-liang-ge-zhan-zu-cheng-de-dui-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="由两个栈组成的队列"><a href="#由两个栈组成的队列" class="headerlink" title="由两个栈组成的队列"></a>由两个栈组成的队列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈实现队列，支持队列的基本操作。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>第一行输入一个整数N，表示对队列进行的操作总数。下面N行每行输入一个字符串S，表示操作的种类。如果S为"add"，则后面还有一个整数X表示向队列尾部加入整数X。如果S为"poll"，则表示弹出队列头部操作。如果S为"peek"，则表示询问当前队列中头部元素是多少。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code>对于每一个为"peek"的操作，输出一行表示当前队列中头部元素是多少。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p><a href="javascript:void(0);">复制</a></p><pre><code>6add 1add 2add 3peekpollpeek</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p><a href="javascript:void(0);">复制</a></p><pre><code>12</code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><pre><code>1&lt;=N&lt;=1000000-1000000&lt;=X&lt;=1000000数据保证没有不合法的操作</code></pre><h2 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h2><ul><li>首先明确队列“First In First Out”的思想，要通过栈（“FILO”）实现队列，则需要两个栈的配合来实现“FIFO”</li><li>队列的操作：add、peek、poll<ul><li>add：添加元素到队列中</li><li>peek：当前队列的头部元素，即最先入队的元素</li><li>poll：弹出队首，即最先入栈的元素</li></ul></li><li>在栈中实现队列操作：<ul><li>add：新元素直接入栈1，并且记录第一个入栈的元素</li><li>peek：两种情况<ul><li>栈2为空：返回栈1中第一个入栈的元素</li><li>栈2不为空：返回栈2的栈顶元素</li></ul></li><li>poll：利用栈弹出队首元素<ul><li>如果栈2为空，将栈1的元素按“FILO”转移到栈2，此时栈2的栈顶即为队首，弹出。</li><li>如果栈2不为空，直接弹出栈2栈顶</li></ul></li></ul></li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StackQueue</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack1<span class="token punctuation">;</span>        <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack2<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> head<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">StackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            stack1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            stack2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stack1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                head <span class="token operator">=</span> data<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            stack1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stack2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>stack1<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    stack2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stack1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            stack2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stack2<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stack2<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">{</span>        StackQueue queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BufferedReader scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> operate <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"add"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"poll"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"peek"</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                queue<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一窥线程究竟</title>
      <link href="2020/10/08/java-bing-fa/yi-kui-xian-cheng-jiu-jing/"/>
      <url>2020/10/08/java-bing-fa/yi-kui-xian-cheng-jiu-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="一窥线程究竟"><a href="#一窥线程究竟" class="headerlink" title="一窥线程究竟"></a>一窥线程究竟</h1><h2 id="一、-什么是线程？什么是进程？二者有什么区别？二者有什么联系？"><a href="#一、-什么是线程？什么是进程？二者有什么区别？二者有什么联系？" class="headerlink" title="一、 什么是线程？什么是进程？二者有什么区别？二者有什么联系？"></a>一、 什么是线程？什么是进程？二者有什么区别？二者有什么联系？</h2><h3 id="1-什么是进程？"><a href="#1-什么是进程？" class="headerlink" title="1. 什么是进程？"></a>1. 什么是进程？</h3><ul><li>进程包括<strong>进程控制块PCB</strong>和<strong>用户地址空间</strong>，所有与进程有关的资源都存放在进程控制块PCB中，包含描述信息、控制信息、资源信息、CPU现场等。</li><li><strong>进程是抢占处理机的调度单位，拥有独立完整的地址空间，线程属于某个进程，共享其资源。</strong></li></ul><p><strong>进程特点</strong></p><p>进程独占内存空间，保存各自运行状态，相互间不干扰且可以互相切换，为并发处理任务提供可能。</p><p>一个进程中可以包含若干个线程。</p><h3 id="2-什么是线程？"><a href="#2-什么是线程？" class="headerlink" title="2. 什么是线程？"></a>2. 什么是线程？</h3><ul><li><strong>线程由堆栈寄存器（存储某线程的局部变量）、程序计数器和线程控制块组成。</strong></li><li><strong>线程属于某个进程，共享同一进程资源。</strong></li></ul><p><strong>线程特点</strong></p><p>线程共享进程内存资源，相互间切换更快捷，支持更细粒度的任务控制，使进程内的子任务得以并发执行。</p><h3 id="3-进程和线程的区别"><a href="#3-进程和线程的区别" class="headerlink" title="3. 进程和线程的区别"></a>3. 进程和线程的区别</h3><ul><li>线程不能看作独立应用，而进程可以看作独立应用</li><li>进程有独立的地址空间， 相互不影响，线程只是进程的不同执行路径</li><li>线程有自己的堆栈，但线程没有独立的地址空间，多进程的程序比多线程程序健壮</li><li>进程的切换比线程的切换开销大</li></ul><h3 id="4-进程和线程的关系"><a href="#4-进程和线程的关系" class="headerlink" title="4. 进程和线程的关系"></a>4. 进程和线程的关系</h3><ul><li>Java对操作系统提供的功能进行封装，包括进程和线程</li><li>运行一个程序会产生一个进程，进程包含至少一个线程</li><li>每个进程对应一个JVM实例，每一个JVM实例对应唯一的一个堆。多个线程共享JVM里的堆，每个线程都有一个私有的栈</li><li>Java采用单线程编程模型，程序会自动创建主线程，即程序默认创建一个主线程，因此要将耗时的操作放在子线程中执行，避免阻塞主线程</li><li>主线程可以创建子线程，原则上要后于子线程完成执行，需要执行各种关闭动作</li></ul><h2 id="二、线程的生命周期（状态转换）"><a href="#二、线程的生命周期（状态转换）" class="headerlink" title="二、线程的生命周期（状态转换）"></a>二、线程的生命周期（状态转换）</h2><p><img src="https://i.loli.net/2020/10/08/TojO6syl39Y1i4K.png" alt="Screen Shot 2020-10-08 at 9.52.49 PM.png"></p><h3 id="1-初始状态（New）"><a href="#1-初始状态（New）" class="headerlink" title="1. 初始状态（New）"></a>1. 初始状态（New）</h3><p>创建后尚未启动。</p><h3 id="2-可运行（Runnable）"><a href="#2-可运行（Runnable）" class="headerlink" title="2. 可运行（Runnable）"></a>2. 可运行（Runnable）</h3><p>可能正在运行，也可能正在等待 CPU 时间片，包含了操作系统线程状态中的 Running 和 Ready。</p><h3 id="3-阻塞（Blocked）"><a href="#3-阻塞（Blocked）" class="headerlink" title="3. 阻塞（Blocked）"></a>3. 阻塞（Blocked）</h3><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><h3 id="4-无限期等待（Waiting）"><a href="#4-无限期等待（Waiting）" class="headerlink" title="4. 无限期等待（Waiting）"></a>4. 无限期等待（Waiting）</h3><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><h3 id="5-超时等待（Time-Waiting）"><a href="#5-超时等待（Time-Waiting）" class="headerlink" title="5. 超时等待（Time Waiting）"></a>5. 超时等待（Time Waiting）</h3><p>在指定时间自行返回。</p><h3 id="6-终止状态"><a href="#6-终止状态" class="headerlink" title="6. 终止状态"></a>6. 终止状态</h3><p>表示当前线程执行完毕或者产生异常结束。</p><h2 id="三、如何使用线程？"><a href="#三、如何使用线程？" class="headerlink" title="三、如何使用线程？"></a>三、如何使用线程？</h2><h3 id="1-如何构建线程（线程初始化）"><a href="#1-如何构建线程（线程初始化）" class="headerlink" title="1. 如何构建线程（线程初始化）"></a>1. 如何构建线程（线程初始化）</h3><p>new Thread过程中会调用Thread包里的init方法：</p><p>由parent线程给线程对象分配空间<br>child线程同时也继承parent线程的基本信息：是否为Daemon、优先级、ThreadLocal等</p><h3 id="2-使用线程的方法有三种"><a href="#2-使用线程的方法有三种" class="headerlink" title="2. 使用线程的方法有三种"></a>2. 使用线程的方法有三种</h3><h4 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 Thread 类</h4><p>Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是调用Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyThread.run()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token punctuation">}</span> MyThread myThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> myThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="2-实现-Runnable-接口"><a href="#2-实现-Runnable-接口" class="headerlink" title="2. 实现 Runnable 接口"></a>2. 实现 Runnable 接口</h4><p>如果自己的类已经继承了另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">OtherClass</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyThread.run()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span>MyThread myThread1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> myThread1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="3-实现-Callable-接口"><a href="#3-实现-Callable-接口" class="headerlink" title="3. 实现 Callable 接口"></a>3. 实现 Callable 接口</h4><p>有返回值的任务必须实现Callable接口，无返回值的任务必须Runnable接口。</p><p>执行Callable任务后，可以获取一个Future的对象，返回值通过 FutureTask 进行封装，在该对象上调用get可以获取到Callable任务返回的Object，再结合线程池接口ExecutorService就可以实现有返回结果的多线程了。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建一个线程池 </span>ExecutorService pool <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>taskSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建多个有返回值的任务 </span>List<span class="token operator">&lt;</span>Future<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Future<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> taskSize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     Callable c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 执行任务并获取Future对象 </span>    Future f <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>     list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 关闭线程池 </span>pool<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取所有并发任务的运行结果 </span><span class="token keyword">for</span> <span class="token punctuation">(</span>Future f <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 从Future对象上获取任务的返回值，并输出到控制台 </span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"res："</span> <span class="token operator">+</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><h4 id="4-基于线程池的方式"><a href="#4-基于线程池的方式" class="headerlink" title="4.基于线程池的方式"></a>4.基于线程池的方式</h4><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么就可以使用缓存的策略，也就是使用线程池。(具体在线程池章节)</p><h4 id="5-实现接口-VS-继承-Thread"><a href="#5-实现接口-VS-继承-Thread" class="headerlink" title="5. 实现接口 VS 继承 Thread"></a>5. 实现接口 VS 继承 Thread</h4><p>实现接口会更好一些，因为：<br>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；<br>类可能只要求可执行就行，继承整个 Thread 类开销过大。</p><h2 id="四、如何终止线程"><a href="#四、如何终止线程" class="headerlink" title="四、如何终止线程"></a>四、如何终止线程</h2><h3 id="1-线程正常运行结束终止"><a href="#1-线程正常运行结束终止" class="headerlink" title="1. 线程正常运行结束终止"></a>1. 线程正常运行结束终止</h3><p>线程执行完run方法，无异常的情况下就会自动退出，终止线程。</p><h3 id="2-使用退出标志位退出线程"><a href="#2-使用退出标志位退出线程" class="headerlink" title="2. 使用退出标志位退出线程"></a>2. 使用退出标志位退出线程</h3><p>线程的run()方法执行完，线程就会正常结束，但是对于线程的伺服线程，它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。</p><p>设置一个boolean类型的标志exit，并通过设置exit标志位为true或false，来控制while循环是否退出，exit为volatile类型，这样能够保证exit对所有线程可见且同步。</p><h3 id="3-中断停止线程"><a href="#3-中断停止线程" class="headerlink" title="3. 中断停止线程"></a>3. 中断停止线程</h3><p><strong>1）线程处于阻塞状态：</strong>如使用了sleep、同步锁的wait、socket中的receiver、accept等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，Thread.interrupt()方法不会中断一个正在运行的线程，阻塞中的方法会抛出InterruptException异常。通过代码捕获该异常，然后break跳出循环状态，从而提早地终结被阻塞状态。</p><p>通常很多人认为只要调用interrupt方法线程就会结束，实际上是错的， 一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正常结束run方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadSafe</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isInterrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//非阻塞过程中通过判断中断标志来退出</span>            <span class="token keyword">try</span><span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//阻塞过程捕获中断异常来退出</span>            <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>InterruptedException e<span class="token punctuation">)</span><span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//捕获到异常之后，执行break跳出循环</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>2）线程未处于阻塞状态：</strong>使用isInterrupted()判断线程的中断标志，来决定是否退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理，但要明白中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 。**</p><p>安全的终止线程：通过标识位和中断操作的方式使得线程有机会清理资源，而不是武断地将线程终止。</p><h3 id="4-调用stop-方法（线程不安全）"><a href="#4-调用stop-方法（线程不安全）" class="headerlink" title="4. 调用stop()方法（线程不安全）"></a>4. 调用stop()方法（线程不安全）</h3><p>程序中可以直接使用thread.stop()来强行终止线程，thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁突然释放，被保护数据就有可能呈现不一致性。</p><p>Thread.suspend, Thread.stop，Thread.sleep方法被终止使用原因</p><p>因为调用这些方法会使线程在未正常结束之前, 被强制终止。<br>这可能带来完全预料不到的严重后果比如会带着自己所持有的锁而永远的休眠，迟迟不归还锁等。</p><h3 id="5-start与run区别"><a href="#5-start与run区别" class="headerlink" title="5. start与run区别"></a>5. start与run区别</h3><p>start()方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码。</p><p>通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。</p><p>方法run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行run函数当中的代码。 Run方法运行结束， 此线程终止。然后CPU再调度其它线程。</p><h2 id="五、线程的基本方法"><a href="#五、线程的基本方法" class="headerlink" title="五、线程的基本方法"></a>五、线程的基本方法</h2><h3 id="1-等待-通知相关方法"><a href="#1-等待-通知相关方法" class="headerlink" title="1. 等待/通知相关方法"></a>1. 等待/通知相关方法</h3><p>join()方法</p><p>如果线程A调用了线程B的Thread.join()，则线程A需要等待线程B结束之后再继续执行。</p><p>为什么要使用Thread.join()？</p><p>很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。</p><p>线程唤醒notify()</p><p>唤醒在此对象监视器上等待的一个线程，使其从wait() 方法返回，前提是该被唤醒的线程获取了对象的锁，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。</p><p>notifyAll()</p><p>唤醒在此对象监视器上等待的所有线程。</p><p>线程等待wait()</p><p>如果线程获取对象锁失败，就要调用该方法进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁。因此，wait方法一般用在同步方法或同步代码块中。</p><p>wait(long)：超时等待，如果等待超时后没有通知就返回（毫秒）。</p><p>wait(long, int)：更细粒度的超时等待（纳秒）。</p><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><h3 id="2-线程的sleep、中断、让步方法"><a href="#2-线程的sleep、中断、让步方法" class="headerlink" title="2. 线程的sleep、中断、让步方法"></a>2. 线程的sleep、中断、让步方法</h3><p>线程睡眠sleep(long)</p><p>sleep导致当前线程休眠<br>sleep不会释放当前占有的锁<br>sleep(long)会导致线程进入TIMED-WATING状态，而wait()方法会导致当前线程进入WATING状态<br>wait() 和 sleep() 的区别</p><p>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法<br>wait() 会释放锁，sleep() 不会。<br>线程中断interrupt()</p><p>调用interrupt()方法并不会中断一个正在运行的线程。<br>处于Running状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。<br>需要进一步处理中断导致的异常或者中断标志位来安全的终止线程。<br>线程让步yield()</p><p>yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片。<br>一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。</p><h2 id="六、线程本地存储-ThreadLocal"><a href="#六、线程本地存储-ThreadLocal" class="headerlink" title="六、线程本地存储 ThreadLocal"></a>六、线程本地存储 ThreadLocal</h2><p>本质上是一个以ThreadLocal为键、任意对象为值的Hashmap存储结构</p><h3 id="1-ThreadLocal的作用"><a href="#1-ThreadLocal的作用" class="headerlink" title="1. ThreadLocal的作用"></a>1. ThreadLocal的作用</h3><p>提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。</p><p>通俗的解释就是，如果代码中所需要的数据必须与其他代码共享，就尝试放在一个线程中，存储起来（ThreadLocal），这样共享数据的可见范围限制在同一个线程之内，无须同步也能保证线程之间不出现数据争用的问题，减少同步带来的额外开销。</p><h3 id="2-如何使用ThreadLocal？"><a href="#2-如何使用ThreadLocal？" class="headerlink" title="2. 如何使用ThreadLocal？"></a>2. 如何使用ThreadLocal？</h3><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-value 键值对插入到该 Map 中，get() 方法类似。</p><h3 id="3-使用ThreadLocal注意事项"><a href="#3-使用ThreadLocal注意事项" class="headerlink" title="3. 使用ThreadLocal注意事项"></a>3. 使用ThreadLocal注意事项</h3><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 锁</title>
      <link href="2020/10/08/java-bing-fa/java-suo/"/>
      <url>2020/10/08/java-bing-fa/java-suo/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-锁"><a href="#Java-锁" class="headerlink" title="Java 锁"></a>Java 锁</h2><h3 id="1-重入锁ReentrantLock（互斥锁、可重入锁）"><a href="#1-重入锁ReentrantLock（互斥锁、可重入锁）" class="headerlink" title="1. 重入锁ReentrantLock（互斥锁、可重入锁）"></a>1. 重入锁ReentrantLock（互斥锁、可重入锁）</h3><p><strong>1）简介</strong></p><p><strong>ReentantLock实现了Lock接口，是一种可重入锁</strong>，除了能完成synchronized所能完成的所有工作外，提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。</p><p><strong>2）公平取锁</strong></p><p><strong>公平锁指的是锁的分配机制是公平的，通常先判断锁是否有前驱节点，等待前驱线程获取并释放锁之后方可继续获取锁。</strong></p><p>ReentrantLock在构造函数中提供了是否公平锁的初始化方式来定义公平锁。</p><p><strong>3）非公平锁</strong></p><p><strong>JVM按随机、就近原则分配锁的机制则称为不公平锁，只要CAS设置同步状态成功就表示获取锁成功，</strong>ReentrantLock默认为非公平锁。<strong>非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则默认非公平锁的分配机制。</strong></p><p><strong>3）使用ReentantLock：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LockExample</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//不要将获取锁过程放在try里，防止发生异常时，导致锁无故释放</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 确保释放锁，从而避免发生死锁。</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="2-Synchronized同步锁（互斥锁、可重入锁）"><a href="#2-Synchronized同步锁（互斥锁、可重入锁）" class="headerlink" title="2. Synchronized同步锁（互斥锁、可重入锁）"></a>2. Synchronized同步锁（互斥锁、可重入锁）</h3><p>synchronized它可以把任意一个非NULL的对象当作锁，<strong>属于独占式的悲观锁，同时属于可重入锁。</strong></p><ul><li><strong>synchronized同步代码块</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>synchronized同步方法</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><ul><li><strong>synchronized同步类</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SynchronizedExample<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li><strong>同步静态方法</strong></li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p><strong>Synchronized如何实现可重入？</strong></p><p><strong>每个锁关联一个线程持有者和一个计数器，当线程获得锁，则计数器加1，</strong>其它线程请求该锁将被阻塞，如果持有锁的线程再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增，<strong>当线程退出Synchronized同步方法或同步块，计数器减1，如果计数器为0，则表示线程释放该锁。</strong></p><h3 id="3-锁和同步的区别（ReentrantLock和Synchronized的区别）"><a href="#3-锁和同步的区别（ReentrantLock和Synchronized的区别）" class="headerlink" title="3. 锁和同步的区别（ReentrantLock和Synchronized的区别）"></a>3. 锁和同步的区别（ReentrantLock和Synchronized的区别）</h3><ul><li><strong>锁的实现</strong><br>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li><li><strong>性能</strong><br>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</li><li><strong>等待可中断</strong><br>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。<br>ReentrantLock 可中断，而 synchronized 不行。</li><li><strong>公平锁</strong><br>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。<br>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</li><li><strong>锁绑定多个条件</strong><br>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</li></ul><h4 id="使用选择"><a href="#使用选择" class="headerlink" title="使用选择"></a>使用选择</h4><p>除非需要使用 ReentrantLock 的高级功能，否则<strong>优先使用 synchronized。这是因为synchronized 是 JVM 实现的一 种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题， synchronized会自动释放锁， JVM 会确保锁的释放。</strong></p><h3 id="4-读写锁（支持重进入的共享锁）"><a href="#4-读写锁（支持重进入的共享锁）" class="headerlink" title="4. 读写锁（支持重进入的共享锁）"></a>4. 读写锁（支持重进入的共享锁）</h3><h4 id="1）-简介"><a href="#1）-简介" class="headerlink" title="1） 简介"></a>1） 简介</h4><p><strong>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。</strong>读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升，读写锁<strong>能有效提高读比写多的场景下的程序性能，比排它锁好。</strong></p><p><img src="https://i.loli.net/2020/10/08/zSACrYWlkhbqZmw.png" alt="Screen Shot 2020-10-08 at 9.42.11 PM.png"></p><h4 id="2）-读写状态设计"><a href="#2）-读写状态设计" class="headerlink" title="2） 读写状态设计"></a>2） 读写状态设计</h4><p><strong>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁是将变量切分成了两个部分，高16位表示读，低16位表示写，划分方式如图所示。</strong></p><p>获取写状态：<br><code>S&amp;0x0000FFFF</code>：将高16位全部抹去</p><p>获取读状态：<br><code>S&gt;&gt;&gt;16</code>：无符号补0，右移16位</p><p>写状态加1：<br><code>S+1</code>：在tryAcquire方法里面</p><p><img src="https://i.loli.net/2020/10/08/qJ5PoulbTRaOhn9.png" alt="Screen Shot 2020-10-08 at 9.42.22 PM.png"></p><h4 id="3）写锁的获取与释放"><a href="#3）写锁的获取与释放" class="headerlink" title="3）写锁的获取与释放"></a>3）写锁的获取与释放</h4><p>写锁是一个支持重进入的排它锁，如果当前线程已经获取了写锁，则增加写状态。</p><p>如果当前线程在获取写锁时，读锁已经被获取（读状态不为0）或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。</p><h4 id="4）读锁的获取与释放"><a href="#4）读锁的获取与释放" class="headerlink" title="4）读锁的获取与释放"></a>4）读锁的获取与释放</h4><p>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会成功的被获取，而所做的也只是（线程安全地）增加读状态。</p><p>如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</p><h4 id="5）锁降级"><a href="#5）锁降级" class="headerlink" title="5）锁降级"></a>5）锁降级</h4><p>锁降级实现方式是：<strong>先获取写入锁，然后把持住当前拥有的写锁，获取读取锁同时，最后释放写入锁。但是，从读取锁升级到写入锁是不可能的。</strong></p><h5 id="锁降级中读锁的获取是否必要呢？"><a href="#锁降级中读锁的获取是否必要呢？" class="headerlink" title="锁降级中读锁的获取是否必要呢？"></a>锁降级中读锁的获取是否必要呢？</h5><p>答案是必要的。</p><p>主要原因是保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，则当前线程无法感知线程T的数据更新。</p><p>如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。</p><h3 id="5-Condition接口（Lock系列功能）"><a href="#5-Condition接口（Lock系列功能）" class="headerlink" title="5. Condition接口（Lock系列功能）"></a>5. Condition接口（Lock系列功能）</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h4><ul><li>Condition就是用来实现类似（Synchronized）Object.wait和Object.notify 对应功能的。</li><li>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁，Condition是依赖Lock对象的。</li><li>调用<strong>await()**方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的</strong>signal()**方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</li></ul><p><em>有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现空位。</em></p><h4 id="2-等待队列"><a href="#2-等待队列" class="headerlink" title="2. 等待队列"></a>2. 等待队列</h4><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点将从尾部加入等待队列。进入等待状态 。</p><p><img src="https://i.loli.net/2020/10/08/xcBGqyHf4u2C7rL.png" alt="Screen Shot 2020-10-08 at 9.42.36 PM.png"></p><p>在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而同步器拥有一个同步队列和多个等待队列。</p><p><img src="https://i.loli.net/2020/10/08/L8YHvpzQBZG4qu3.png" alt="Screen Shot 2020-10-08 at 9.42.51 PM.png"></p><h4 id="3-等待"><a href="#3-等待" class="headerlink" title="3. 等待"></a>3. 等待</h4><p>调用Condition的await()方法，会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</p><p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。</p><p><img src="https://i.loli.net/2020/10/08/NSwZOmJL1jMGbzd.png" alt="Screen Shot 2020-10-08 at 9.43.00 PM.png"></p><h4 id="4-通知"><a href="#4-通知" class="headerlink" title="4. 通知"></a>4. 通知</h4><p>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中。<br>调用该方法的前置条件是当前线程必须获取了锁，接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</p><p><img src="https://i.loli.net/2020/10/08/XH5NyjeLRapYGFW.png" alt="Screen Shot 2020-10-08 at 9.43.10 PM.png"></p><p><strong>LockSupport定义了一组park开头的方法阻塞当前线程，unpark方法唤醒一个被阻塞的线程。</strong></p><h3 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4. 乐观锁和悲观锁"></a>4. 乐观锁和悲观锁</h3><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁<strong>认为读多写少，遇到并发写的可能性低，</strong>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。</p><p><strong>在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。</strong></p><p><strong>乐观锁基本都是通过CAS操作实现的</strong>，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁是就是悲观思想，即<strong>认为写多，遇到并发写的可能性高，</strong>每次去拿数据的时候都认为别人会修改，所以<strong>每次在读写数据的时候都会上锁</strong>，这样别人想读写这个数据就会阻塞直到拿到锁。</p><p><strong>Synchronized是悲观锁，AQS框架下的锁则是先尝试cas操作乐观锁去获取锁，获取不到锁，就会转换为悲观锁，如ReentrantLock。</strong></p><h3 id="5-共享锁和独占锁"><a href="#5-共享锁和独占锁" class="headerlink" title="5. 共享锁和独占锁"></a>5. 共享锁和独占锁</h3><h4 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h4><ul><li>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。</li><li>独占锁是一种悲观保守的加锁策略，它避免了读/读冲突。</li></ul><h4 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h4><ul><li>共享锁允许多个线程同时获取锁，并发访问共享资源，如：ReadWriteLock。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</li><li>共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</li></ul><h3 id="6-自旋锁"><a href="#6-自旋锁" class="headerlink" title="6. 自旋锁"></a>6. 自旋锁</h3><blockquote><p>只适用于共享数据的锁定状态很短的场景。</p></blockquote><ul><li>如果持有锁的线程能在很短时间内释放锁资源</li><li>等待竞争锁的线程就不需要进入阻塞挂起状态，只需要等一等（自旋）</li><li>等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</li></ul><p><strong>但是线程自旋是需要消耗cup的，所以需要设定一个自旋等待的最大时间。</strong></p><p><strong>自旋锁可以尽可能的减少线程的阻塞，但是如果锁的竞争激烈，则自旋锁会消耗大量资源。</strong></p><h3 id="7-锁优化"><a href="#7-锁优化" class="headerlink" title="7. 锁优化"></a>7. 锁优化</h3><p><strong>1）减少锁持有时间</strong></p><p>只在有线程安全要求的程序上加锁。</p><p><strong>2）减小锁粒度</strong></p><p>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。<strong>降低锁的竞争，偏向锁，轻量级锁成功率才会提高，典型的减小锁粒度的案例就是ConcurrentHashMap。</strong></p><p><strong>3）锁分离</strong></p><p>最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能。</p><p><strong>4）锁粗化</strong></p><p>如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 ，所以粗化这类锁的请求释放过程，<strong>把加锁的范围扩展（粗化）到整个操作序列的外部。</strong></p><p><strong>5）锁消除</strong></p><p>在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作。</p><h3 id="8-队列同步器AQS（构建锁的同步组件的框架）"><a href="#8-队列同步器AQS（构建锁的同步组件的框架）" class="headerlink" title="8. 队列同步器AQS（构建锁的同步组件的框架）"></a>8. 队列同步器AQS（构建锁的同步组件的框架）</h3><h4 id="1）简介"><a href="#1）简介" class="headerlink" title="1）简介"></a>1）简介</h4><p>队列同步器 AbstractQueuedSynchronizer（简称同步器）是锁和其他同步组件的基础框架，内部<strong>使用了一个 int 类型的成员变量来表示同步状态，还使用了一个 FIFO 队列来管理线程的排队工作。</strong></p><p>同步器提供了3个方法来修改和访问同步状态：</p><ul><li>getState()：获取当前同步状态</li><li>setState(int newState)：设置当前同步状态</li><li>compareAndSetState(int expect, int update)：使用CAS设置当前状态，该方法能保证操作的原子性。</li></ul><p><img src="https://i.loli.net/2020/10/08/DmpfUX3MvtjcilE.png" alt="Screen Shot 2020-10-08 at 9.43.46 PM.png"></p><h4 id="2）同步队列"><a href="#2）同步队列" class="headerlink" title="2）同步队列"></a>2）同步队列</h4><ul><li>同步器内部通过 FIFO 队列（双向链表）来管理那些获取同步状态失败的线程。</li><li>当线程获取同步状态失败后，会将当前线程以及一些状态信息构造成一个节点（Node）添加到队列的尾部，同时阻塞该线程。<strong>这个添加过程必须是线程安全的，通过CAS 的方法添加节点。</strong></li><li>当同步状态被释放后，会把后继节点的线程唤醒并尝试获取同步状态。</li></ul><p><img src="https://i.loli.net/2020/10/08/l7CxMqLwTtjp2og.png" alt="Screen Shot 2020-10-08 at 9.44.01 PM.png"></p><h4 id="3）独占式获取与释放同步状态"><a href="#3）独占式获取与释放同步状态" class="headerlink" title="3）独占式获取与释放同步状态"></a>3）独占式获取与释放同步状态</h4><h5 id="独占式获取同步状态"><a href="#独占式获取同步状态" class="headerlink" title="独占式获取同步状态"></a>独占式获取同步状态</h5><p>调用同步器的 <code>acquire(int arg)</code> 方法可以获取同步状态，该方法不响应中断操作。也就是说当线程获取同步状态失败后会加入到同步队列中，如果此时对线程进行中断操作，线程不会从同步队列中移出。</p><p>在获取同步状态时，同步器维护了一个同步队列，获取状态失败的线程都会被构建成节点加入到队列中并进行自旋；<strong>移出队列的条件是前驱节点为头节点且成功获取了同步状态。</strong></p><h5 id="独占式释放同步状态"><a href="#独占式释放同步状态" class="headerlink" title="独占式释放同步状态"></a>独占式释放同步状态</h5><p>线程获取同步状态成功并执行完相关逻辑后就要释放同步状态，后继节点就可以继续获取同步状态，调用同步器的 <code>release(int arg)</code> 方法可以释放同步状态，唤醒后继节点的线程。</p><h4 id="4）共享式获取与释放同步状态"><a href="#4）共享式获取与释放同步状态" class="headerlink" title="4）共享式获取与释放同步状态"></a>4）共享式获取与释放同步状态</h4><p>共享式与独占式最大的区别在于：同一个时刻能否允许多个线程同时获取到同步状态。</p><h5 id="共享式获取同步状态"><a href="#共享式获取同步状态" class="headerlink" title="共享式获取同步状态"></a>共享式获取同步状态</h5><p>调用同步器的 <code>acquireShared(int arg)</code> 方法可以获取同步状态。</p><h5 id="共享式释放同步状态"><a href="#共享式释放同步状态" class="headerlink" title="共享式释放同步状态"></a>共享式释放同步状态</h5><p>和独占式一样，共享式也需要释放同步状态，通过调用同步器的 <code>releaseShared(int arg)</code> 方法释放同步状态。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程上下文切换</title>
      <link href="2020/10/08/java-bing-fa/xian-cheng-shang-xia-wen-qie-huan/"/>
      <url>2020/10/08/java-bing-fa/xian-cheng-shang-xia-wen-qie-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h1><h2 id="1-什么是上下文切换？"><a href="#1-什么是上下文切换？" class="headerlink" title="1. 什么是上下文切换？"></a>1. 什么是上下文切换？</h2><p>CPU通过时间片轮转的方式，当前任务执行一个时间片，然后保存当前任务状态，执行下一个任务，<strong>任务从保存到再加载的过程就叫做上下文切换。</strong></p><p>上下文切换是内核在 CPU 上对进程（包括线程）进行切换，上下文切换过程中的信息保存在进程控制块（PCB, process control block）中，任务信息会一直保存在CPU的内存中，直到他们被再次使用更新。</p><h2 id="2-为什么会上下文切换？"><a href="#2-为什么会上下文切换？" class="headerlink" title="2. 为什么会上下文切换？"></a>2. 为什么会上下文切换？</h2><ol><li><p>当前执行任务的时间片用完之后，系统CPU正常调度下一个任务。</p></li><li><p>当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务 。</p></li><li><p>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务。</p></li><li><p>用户代码挂起当前任务，让出CPU时间片。</p></li><li><p>硬件中断。</p></li></ol><h2 id="3-上下文切换如何执行？"><a href="#3-上下文切换如何执行？" class="headerlink" title="3. 上下文切换如何执行？"></a>3. 上下文切换如何执行？</h2><ol start="6"><li><p>挂起一个进程，将这个进程在 CPU 中的状态存储在PCB中。</p></li><li><p>CPU检索下一个进程的上下文信息并将其在 CPU 的寄存器中恢复。</p></li><li><p>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复继续执行该进程。</p></li></ol><h2 id="4-如何减少上下文切换？"><a href="#4-如何减少上下文切换？" class="headerlink" title="4. 如何减少上下文切换？"></a>4. 如何减少上下文切换？</h2><ol><li>无锁并发编程</li><li>使用CAS算法更新数据，无需加锁</li><li>使用最少线程</li><li>协程：在单线程实现多任务调度，并在单线程中维持多个任务的切换</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发机制实现原理</title>
      <link href="2020/10/08/java-bing-fa/java-bing-fa-ji-zhi-shi-xian-yuan-li/"/>
      <url>2020/10/08/java-bing-fa/java-bing-fa-ji-zhi-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发机制实现原理"><a href="#Java并发机制实现原理" class="headerlink" title="Java并发机制实现原理"></a>Java并发机制实现原理</h1><h2 id="1-Volatile"><a href="#1-Volatile" class="headerlink" title="1. Volatile"></a>1. Volatile</h2><h3 id="1-1-volatile的定义"><a href="#1-1-volatile的定义" class="headerlink" title="1.1 volatile的定义"></a>1.1 volatile的定义</h3><p>volatile是比sycronized轻量级的同步锁，被声明为volatile的变量，线程会通过排他锁单独获得这个变量，使得volatile变量被准确和一致地更新。</p><p><strong>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</strong></p><h3 id="1-2-volatile的实现原理"><a href="#1-2-volatile的实现原理" class="headerlink" title="1.2 volatile的实现原理"></a>1.2 volatile的实现原理</h3><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可能保存不同缓存下的变量值。</p><p><strong>volatile变量更新时：JVM会向处理器发送Lock前缀指令，使这个变量在缓存行中的数据写回到内存中，其它处理器会根据缓存一致性协议，嗅探总线的数据检查自己的缓存是否过期，然后及时从内存中把更新后的数据读到处理器缓存中。</strong></p><p>总结起来就是两条原则：</p><ul><li><strong>Lock前缀指令将处理器缓存回写到内存</strong></li><li><strong>一个处理器的缓存回写到内存导致其他处理器缓存无效，从内存中更新缓存数据，保证数据一致性</strong></li></ul><h3 id="1-3-volatile的优化"><a href="#1-3-volatile的优化" class="headerlink" title="1.3 volatile的优化"></a>1.3 volatile的优化</h3><p><strong>不足</strong></p><p>在使用volatile时，由于缓存一致性原则，处理器需要更新缓存行，但是处理器的每个缓存行一般是64字节的，如果头节点和尾节点不足64字节，它们就会在同一个缓存行，但是如果更改头节点时，处理器就会锁定整个缓存行，导致其它处理器无法更改尾节点。</p><p><strong>优化</strong></p><p><strong>使用volatile变量时追加到64字节填满缓存行，避免头节点和尾节点加载到同一个缓存行，使头尾节点不会互相锁定。</strong></p><h2 id="2-Synchronized"><a href="#2-Synchronized" class="headerlink" title="2. Synchronized"></a>2. Synchronized</h2><h3 id="2-1-synchronized实现原理"><a href="#2-1-synchronized实现原理" class="headerlink" title="2.1 synchronized实现原理"></a>2.1 synchronized实现原理</h3><p><strong>synchronized实现同步的表现形式：</strong></p><ul><li>普通同步方法，锁使实例对象</li><li>静态同步方法，锁是类的Class对象</li><li>同步方法快，锁是synchronized括号里配置的对象</li></ul><p><strong>JVM利用Monitor对象实现方法和代码块同步，具体是利用monitorenter和monitorexit指令实现，当monitor被对象持有后，则此对象处于锁定状态，线程执行到monitorenter指令时，将尝试获取monitor所有权，即获取对象的锁。</strong></p><h3 id="2-2-对象头——synchronized锁存储的地方"><a href="#2-2-对象头——synchronized锁存储的地方" class="headerlink" title="2.2 对象头——synchronized锁存储的地方"></a>2.2 对象头——synchronized锁存储的地方</h3><p>synchronized锁存在对象头里，<strong>锁状态存储在对象头里的Mark Word里。</strong></p><p><strong>锁状态：</strong></p><ul><li>重量级锁</li><li>轻量级锁</li><li>偏向锁</li><li>GC标记（无锁状态）</li></ul><h3 id="2-3-锁状态详解"><a href="#2-3-锁状态详解" class="headerlink" title="2.3 锁状态详解"></a>2.3 锁状态详解</h3><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>加锁和解锁不需要额外消耗，适用只有一个线程访问同步块的场景</strong></p><p><strong>1）为什么会有偏向锁？</strong><br><strong>大多数情况锁不存在竞争，而且总是由同一线程获得，因此偏向锁适用于极少存在所竞争的情况。</strong><br>在线程获取锁时，在锁栈帧中记录线程ID，为了减少加锁和解锁的开销，引入偏向锁，使得获取过所得线程在进入或退出同步块不需要CAS操作，根据线程ID，只需简单监测Mark Word里所状态是否指向当前线程的偏向锁，如果是则表示线程获取了锁，不是则使用CAS竞争锁，将对象头的偏向锁指向当前线程。</p><p><em>偏向锁是默认启用的</em></p><p><strong>2）撤销偏向锁</strong></p><p>当其他线程竞争偏向锁时，持有偏向锁的线程才会释放锁，撤销偏向锁，需要等待全局安全点，即没有正在执行的字节码时开始撤销偏向锁。</p><p><strong>步骤：</strong></p><ol><li>在全局安全点，暂停拥有偏向锁的线程</li><li>检查线程是否还活着，如果线程不活着，将对象头设置为无锁状态；如果线程还活着，则遍历偏向锁持有的对象的锁记录，更新对象头偏向锁指向的线程ID到其他线程或者设置为无锁状态或者标记对象不适合作为偏向锁。</li></ol><p><strong>3）删除偏向锁</strong></p><p><strong>如果程序中的锁都存在竞争情况，则可以通过JVM关闭偏向锁，程序会默认进入轻量级所状态。</strong></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><strong>竞争的线程不会阻塞，但得不到锁的进程会因为自旋等待消耗cpu，适用同步块执行速度快的场景</strong></p><p><strong>1）轻量级锁的获取</strong></p><ul><li>JVM向线程分配存储锁记录空间，复制Mark Word到线程栈的锁记录空间</li><li>CAS修改对象头Mark Word为轻量级锁</li><li>如果获取失败，线程尝试使用自旋来获取锁（线程没有被阻塞）</li></ul><p><strong>2）轻量级锁的解锁</strong>（注意不是让拥有锁的线程释放锁）</p><ul><li>CAS替换Mark Word，成功则表示不存在锁竞争</li><li>若替换失败，则锁膨胀成为重量级锁，锁一旦成为重量级锁，就不能再恢复成轻量级锁</li></ul><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p><strong>在锁处于重量级锁状态下，其他线程获取锁时，都将被阻塞，线程不存在自旋，因此不会消耗cpu，但是线程会被阻塞，因此响应时间延长，使用同步执行块执行时间较长吞吐量大的场景。</strong></p><h2 id="3-原子操作原理"><a href="#3-原子操作原理" class="headerlink" title="3. 原子操作原理"></a>3. 原子操作原理</h2><p><strong>定义：不能被中断的一个或一系列的操作</strong></p><h3 id="3-1-处理器实现原子操作的方式"><a href="#3-1-处理器实现原子操作的方式" class="headerlink" title="3.1 处理器实现原子操作的方式"></a>3.1 处理器实现原子操作的方式</h3><p><strong>1）使用总线锁（LOCK #信号）保证原子性</strong>，当一个处理器在总线输出此信号该处理器独占共享内存，其它处理器请求被阻塞。</p><p><strong>2）使用缓存锁保证原子性</strong>，如果内存在Lock期间被锁定过，再次执行锁操作，则无需声明总线锁，根据缓存一致性保证操作的原子性。</p><h3 id="3-2-Java实现原子操作的方式"><a href="#3-2-Java实现原子操作的方式" class="headerlink" title="3.2 Java实现原子操作的方式"></a>3.2 Java实现原子操作的方式</h3><p><strong>1）使用自旋（循环）CAS实现原子操作（无锁）</strong></p><p><strong>循环进行CAS操作直到成功为止，利用处理器提供的CMPXCHG指令实现</strong>，原子操作并发包包含：AtomicBoolean、AtomicInteger、AtomicLong</p><p><strong>2）使用锁机制实现原子操作</strong></p><p>锁机制保证线程在只有获得锁的情况下才能操作锁定的内存区域，java中除了偏向锁，都用了循环CAS实现锁。</p><h2 id="4-什么是CAS操作？（比较并交换）"><a href="#4-什么是CAS操作？（比较并交换）" class="headerlink" title="4. 什么是CAS操作？（比较并交换）"></a>4. 什么是CAS操作？（比较并交换）</h2><h3 id="4-1-CAS定义"><a href="#4-1-CAS定义" class="headerlink" title="4.1 CAS定义"></a>4.1 CAS定义</h3><p>CAS（Compare And Swap/Set）比较并交换，CAS(V,E,N)算法包含3个参数：<strong>V表示要更新的变量(内存值)，E表示预期值(旧的)，N表示新值。</strong>CAS操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p><h3 id="4-2-CAS原子操作存在的问题"><a href="#4-2-CAS原子操作存在的问题" class="headerlink" title="4.2 CAS原子操作存在的问题"></a>4.2 CAS原子操作存在的问题</h3><p><strong>1）ABA问题</strong></p><p>如果线程1使用CAS操作从内存中取出A，线程2也从内存中取出A，并将A变成了B，再将B变成A，虽然线程1是CAS原子操作，发现内存中仍然是A，但是实际这个过程并不是原子操作。</p><p><strong>解决办法：</strong></p><p>使用版本号，在变量前面追加版本号，每次变量更新，把版本号+1。A-&gt;B-&gt;A 变为 1A-&gt;2B-&gt;3A</p><p><em>AtomicStampedReference类解决了ABA问题</em></p><p><strong>2）循环时间长开销大</strong></p><p>如果自旋CAS长时间不成功，给cpu造成负担。JVM通过pause指令提升效率。</p><p><strong>3) 只能保证一个共享变量的原子操作</strong></p><p>解决办法：</p><ul><li>把多个共享变量合并成一个：AtomicReference类保证对象间原子性，使多个变量放在一个对象进行CAS原子操作</li><li>使用锁</li></ul><h2 id="5-同步锁和死锁"><a href="#5-同步锁和死锁" class="headerlink" title="5. 同步锁和死锁"></a>5. 同步锁和死锁</h2><p><strong>同步锁</strong></p><p>为了避免多个线程同时访问同一个数据时，造成数据不一致等问题，需要保证线程同步互斥。也就是<strong>指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java中可以使用synchronized关键字来取得一个对象的同步锁。</strong></p><p><strong>死锁</strong></p><p>死锁就是<strong>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="2020/10/08/java-bing-fa/java-nei-cun-mo-xing/"/>
      <url>2020/10/08/java-bing-fa/java-nei-cun-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><h2 id="1-Java并发采用哪种模型？"><a href="#1-Java并发采用哪种模型？" class="headerlink" title="1. Java并发采用哪种模型？"></a>1. Java并发采用哪种模型？</h2><p><strong>共享内存并发模型：</strong>线程之间共享程序的公共状态，通过<strong>写-读</strong>内存中的公共状态进行隐式通信。</p><h2 id="2-Java内存模型结构是什么样的？"><a href="#2-Java内存模型结构是什么样的？" class="headerlink" title="2. Java内存模型结构是什么样的？"></a>2. Java内存模型结构是什么样的？</h2><p>线程之间的共享变量存在<strong>主内存</strong>中，每个线程有一个<strong>工作内存</strong>读/写共享变量的副本，注意这里的工作内存并不存在，只是一个抽象概念。<strong>Java内存模型本身也是一种抽象的概念。</strong></p><p><strong>主内存：</strong>所有线程创建的实例对象都存放在主内存中。</p><p><strong>工作内存：</strong>存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每个线程只能访问自己的工作内存。</p><p><img src="https://i.loli.net/2020/10/08/Z5EDf8IdpanF7Ov.png" alt="Screen Shot 2020-10-08 at 9.40.03 PM.png"></p><h2 id="3-Java内存模型和Java内存区域有什么联系，如何区分？"><a href="#3-Java内存模型和Java内存区域有什么联系，如何区分？" class="headerlink" title="3. Java内存模型和Java内存区域有什么联系，如何区分？"></a>3. Java内存模型和Java内存区域有什么联系，如何区分？</h2><p>Java内存模型是一个抽象概念，描述的是一组规则，围绕原子性、有序性、可见性展开，Java内存区域是在内存JVM中实际的划分，一个是抽象概念一个是实际划分，二者在某些概念上有一些联系，比如内存区域的共享数据区和私有数据区，可以对应JMM中的主内存区域，JMM中的私有区域或者工作内存可以对应JVM中的虚拟机栈和本地方法栈以及程序计数器。</p><h2 id="4-设定Java内存模型解决了什么问题，带来了什么问题，如何解决？"><a href="#4-设定Java内存模型解决了什么问题，带来了什么问题，如何解决？" class="headerlink" title="4. 设定Java内存模型解决了什么问题，带来了什么问题，如何解决？"></a>4. 设定Java内存模型解决了什么问题，带来了什么问题，如何解决？</h2><p><strong>解决的问题：</strong>在线程并发时，处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存（工作内存概念）</p><p><strong>带来的问题：</strong>高速缓存带来了<strong>缓存一致性的问题</strong>，多个线程的多个缓存共享一个主内存区域，那么就可能出现数据一致性问题。</p><p><strong>如何解决：</strong>需要一个能够维护缓存一致性的协议（原则）：<strong>原子性、可见性、有序性、以及为了提高性能对指令的重排序原则。维护这些原则对性能消耗也变大了，因此编译器和处理器也会对指令进行重排序，来提高性能。</strong></p><h2 id="5-JMM保证原子性、可见性、有序性的解决方案"><a href="#5-JMM保证原子性、可见性、有序性的解决方案" class="headerlink" title="5. JMM保证原子性、可见性、有序性的解决方案"></a>5. JMM保证原子性、可见性、有序性的解决方案</h2><p><strong>1）原子性：</strong>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性。</p><p>实现方式：</p><ul><li><strong>使用synchronized关键字或者重入锁(ReentrantLock)保证程序执行的原子性。</strong></li></ul><p><strong>2）可见性：</strong>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性。</p><p>实现方式：<strong>设置内存屏障：LoadLoad Barriers、StoreStore Barriers、LoadStore Barriers、StoreLoad Barriers(全能)</strong></p><ul><li><strong>使用volatile修饰变量</strong></li><li><strong>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</strong></li><li><strong>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</strong></li></ul><p><strong>3）有序性：</strong>在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，<strong>无序是因为发生了指令重排序。</strong></p><p>实现方式：</p><ul><li><strong>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前，从而保证有序性。</strong></li><li><strong>synchronized 也可以有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同<br>步代码。</strong></li></ul><p><strong>4）JMM内部还通过“happens-before 原则“来保证多线程环境下两个操作间的原子性、可见性以及有序性。</strong></p><h2 id="6-如何理解重排序？"><a href="#6-如何理解重排序？" class="headerlink" title="6. 如何理解重排序？"></a>6. 如何理解重排序？</h2><p>简单的说就是在不违反有序性、可见性、原子性的前提下，进行重排序以提高性能。</p><ul><li><strong>编译器优化的重排</strong></li></ul><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><ul><li><strong>指令并行的重排</strong></li></ul><p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应的机器指令的执行顺序</p><ul><li><strong>内存系统的重排</strong></li></ul><p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，处理器允许写-读操作重排序。</p><p>以上是可能会发生重排序的情况，因此在多线程的情况下，指令重排序可能会出现诸多问题，<strong>在多线程中，存在控制依赖的操作重排序，可能会改变程序的执行结果。</strong>因此要依从happens-before原则来避免在多线程情况下重排序导致的问题。</p><h2 id="7-如何理解happens-before-原则"><a href="#7-如何理解happens-before-原则" class="headerlink" title="7. 如何理解happens-before 原则"></a>7. 如何理解happens-before 原则</h2><p>如果仅靠synchronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，因此<strong>Java并发模型提供happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据</strong>。</p><ul><li>程序顺序原则：在一个线程内，在程序前面的操作先行发生于后面的操作。</li><li>锁规则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</li><li>volatile规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</li><li>线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</li><li>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。</li><li>线程终止规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li><li>线程中断规则： 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</li><li>对象终结规则：对象的构造函数执行，结束先于finalize()方法<br>传递性：A先于B ，B先于C 那么A必然先于C</li></ul><h2 id="8-volatile、锁、final域的内存语义"><a href="#8-volatile、锁、final域的内存语义" class="headerlink" title="8. volatile、锁、final域的内存语义"></a>8. volatile、锁、final域的内存语义</h2><p><strong>volatile内存语义</strong></p><ul><li>保证被volatile修饰的共享变量对所有线程总数可见的。</li><li>禁止指令重排序优化，从而避免多线程环境下程序出现乱序执行的现象。</li></ul><p><strong>锁的内存语义</strong></p><ul><li>公平锁利用volatile写读所具有的内存语义</li><li>非公平锁利用CAS附带的volatile读和volatile写的内存语义</li></ul><p><strong>final域的内存语义</strong></p><ul><li>只要对象是正确构造，就不需要同步来保证线程看到final域在初始化后的值。</li></ul><h2 id="9-延迟初始化的解决方案"><a href="#9-延迟初始化的解决方案" class="headerlink" title="9. 延迟初始化的解决方案"></a>9. 延迟初始化的解决方案</h2><p><em>延迟初始化可以降低初始化类和创建对象的开销。</em></p><ul><li><strong>对实例字段使用线程安全的延迟初始化，采用基于volatile的延迟初始化方案</strong></li><li><strong>对静态字段使用线程安全的延迟初始化，采用基于类的延迟初始化方案</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现getMin栈</title>
      <link href="2020/10/08/shu-ju-jie-gou-yu-suan-fa/zhan/shi-xian-getmin-zhan/"/>
      <url>2020/10/08/shu-ju-jie-gou-yu-suan-fa/zhan/shi-xian-getmin-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="实现getMin栈"><a href="#实现getMin栈" class="headerlink" title="实现getMin栈"></a>实现getMin栈</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>实现一个特殊功能的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h2><pre><code>第一行输入一个整数N，表示对栈进行的操作总数。下面N行每行输入一个字符串S，表示操作的种类。如果S为"push"，则后面还有一个整数X表示向栈里压入整数X。如果S为"pop"，则表示弹出栈顶操作。如果S为"getMin"，则表示询问当前栈中的最小元素是多少。</code></pre><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h2><pre><code>对于每个getMin操作，输出一行表示当前栈中的最小元素是多少。</code></pre><p>示例1</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>6push 3push 2push 1getMinpopgetMin</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>12</code></pre><h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><pre><code>1&lt;=N&lt;=1000000-1000000&lt;=X&lt;=1000000数据保证没有不合法的操作</code></pre><h2 id="解题思想"><a href="#解题思想" class="headerlink" title="解题思想"></a>解题思想</h2><ul><li>首先把握栈的核心思想是“First In Last Out”，如果需要知道当前栈中最小的元素，那么就需要维护这个最小值，维护的方式可以是指针或者让栈顶一直是最小值，但是使用一个栈的话，代价都太大了，因此可以单独拿出一个栈来维护最小值虽然这也会增加空间消耗。</li><li>stackData：保存当前栈中的元素，其功能和一个正常的栈没有区别，这个栈记为stackData；另一个栈用于保存每一步的最小值，这个栈记为stackMin”</li><li>stackMin：最小栈，专门维护保存每一步操作时的最小值</li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">minStack</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stackData<span class="token punctuation">;</span>        <span class="token keyword">private</span> Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stackMin<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//初始化两个栈</span>        <span class="token keyword">public</span> <span class="token function">minStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>stackData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>stackMin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//push操作：如果push元素小于最小栈的栈顶元素，data需push到最小栈</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>            stackData<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stackMin<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>                stackMin<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> data<span class="token punctuation">)</span><span class="token punctuation">{</span>                stackMin<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//peek最小栈栈顶元素即可</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stackMin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//记住要同时pop两个栈的栈顶元素</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>stackData<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> stackMin<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"stack is empty"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>                stackData<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                stackMin<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//基于whiteboard将输入样例输入，要注意编写格式的转换</span>      <span class="token comment" spellcheck="true">//使用BufferedReader创建输入实例</span>      <span class="token comment" spellcheck="true">//使用Integer.parseInt转换参数格式</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">{</span>        minStack stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">minStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        BufferedReader scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//输入操作，同时去除 具体操作和数字之间的空格</span>            <span class="token comment" spellcheck="true">//String[0]表示操作类型 String[1]表示参数</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> operate <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"push"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"pop"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>operate<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"getMin"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                stack<span class="token punctuation">.</span><span class="token function">getMin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        scanner<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是SOCKET连接？</title>
      <link href="2020/10/07/wang-luo/shi-me-shi-socket-lian-jie/"/>
      <url>2020/10/07/wang-luo/shi-me-shi-socket-lian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SOCKET连接？"><a href="#什么是SOCKET连接？" class="headerlink" title="什么是SOCKET连接？"></a>什么是SOCKET连接？</h1><h2 id="1-套接字（socket）概念"><a href="#1-套接字（socket）概念" class="headerlink" title="1. 套接字（socket）概念"></a>1. 套接字（socket）概念</h2><ul><li>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元，也是其中间抽象层接口，Scoket将TCP/IP复杂的处理方法隐藏在接口之后，对于用户而言只需要调用Scoket接口服务即可获取相应网络服务。</li><li>包含进行网络通信必须的五种信息：<strong>连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</strong></li><li>socket 其实就是一个五元组，包括：<strong>源IP, 源端口, 目的IP, 目的端口, 类型(TCP or UDP)</strong> 这个五元组，即标识了一条可用的连接。</li></ul><blockquote><p>为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p></blockquote><p><img src="https://i.loli.net/2020/10/08/TbsPqFHCdaKOnhD.png" alt="socket.png"></p><h2 id="2-建立socket连接"><a href="#2-建立socket连接" class="headerlink" title="2. 建立socket连接"></a>2. 建立socket连接</h2><ul><li>建立Socket连接至少需要一对套接字</li><li>ClientSocket运行于客户端</li><li>ServerSocket运行于服务器端</li></ul><p><strong>套接字之间的连接过程分为三个步骤：</strong></p><ol><li>服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li>客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li><li>连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发 给客户端，一旦客户端确认了此描述，双方就正式建立连接。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ol><h2 id="3-Socket通信过程"><a href="#3-Socket通信过程" class="headerlink" title="3. Socket通信过程"></a>3. Socket通信过程</h2><p><strong>客户端请求</strong> -&gt; 序列化 -&gt; write buffer -&gt; socket -&gt; TCP/IP or UDP -&gt; 客户端链路 -&gt; 交换机 -&gt; 路由 -&gt; 交换机 -&gt; 服务端链路 -&gt; TCP/IP or UDP -&gt; socket -&gt; read buffer -&gt; 反序列化 -&gt; <strong>服务端响应</strong> -&gt; 序列化 -&gt; write buffer -&gt; socket -&gt; TCP/IP or UDP -&gt; 服务端链路 -&gt; 交换机 -&gt; 路由 -&gt; 交换机 -&gt; <strong>客户端接收响应</strong> -&gt; 链路 -&gt; TCP/IP or UDP -&gt; socket -&gt; read buffer -&gt; <strong>关闭连接</strong></p><p><strong>服务端</strong></p><ol><li><p>初始化Socket<code>socket()</code></p></li><li><p>与端口绑定<code>bind()</code></p></li><li><p>对端口进行监听<code>listen()</code></p></li><li><p>调用<code>accept()</code>堵塞等待客户端连接</p></li></ol><p><strong>客户端</strong></p><ol><li>初始化Socket<code>socket()</code></li><li>与端口绑定<code>bind()</code></li><li>连接服务端<code>connect()</code></li><li>连接成功，发送请求<code>write()</code></li></ol><p>客户端首先封装一个请求对象<code>req</code>，将其序列化成为字节数组（序列化后的请求消息对象<code>req</code>），同时拷贝到操作系统到内核区套接字对象的<code>write buffer</code>中，内核网络模块会有单独的线程负责不停地将<code>write buffer</code>的数据拷贝到网卡硬件，网卡硬件再将数据传送到网线，经过一系列路由器和交换机，最终送达服务器的网卡硬件中。</p><p><strong>服务端</strong></p><ol><li>接收请求并处理<code>read()</code></li><li>将回应发送给客户端<code>write()</code></li></ol><p>服务端内核的网络模块也有单独的线程不停地接收到数据拷贝到套接字的<code>read buffer</code>中等待用户层来读取，最终服务端的用户进程通过socket引用的<code>read()</code>方法将<code>read buffer</code>中的数据拷贝到用户程序内部中，进行反序列化成请求对象<code>req</code>进行处理，然后服务端将处理后的响应对象，按相反的流程发送给客户端。</p><p><strong>客户端</strong></p><ol><li>读取来自服务端的响应<code>read()</code></li><li>关闭连接<code>close()</code>，交互结束  </li></ol><p><img src="https://i.loli.net/2020/10/08/F5phlcGDNL8tEJk.png" alt="socket_response"></p><h2 id="4-Socket连接与TCP连接"><a href="#4-Socket连接与TCP连接" class="headerlink" title="4. Socket连接与TCP连接"></a>4. Socket连接与TCP连接</h2><ul><li>创建Socket连接时，可以指定使用的传输层协议</li><li>Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</li></ul><h2 id="5-Socket连接与HTTP连接"><a href="#5-Socket连接与HTTP连接" class="headerlink" title="5. Socket连接与HTTP连接"></a>5. Socket连接与HTTP连接</h2><ul><li>HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。</li><li>若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端。</li><li>若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 套接字 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/07/java-ji-chu/java8/"/>
      <url>2020/10/07/java-ji-chu/java8/</url>
      
        <content type="html"><![CDATA[<h1 id="Java8"><a href="#Java8" class="headerlink" title="Java8"></a>Java8</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/07/java-ji-chu/dong-tai-dai-li/"/>
      <url>2020/10/07/java-ji-chu/dong-tai-dai-li/</url>
      
        <content type="html"><![CDATA[<h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/07/java-ji-chu/fan-she/"/>
      <url>2020/10/07/java-ji-chu/fan-she/</url>
      
        <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="2020/10/07/wang-luo/io/"/>
      <url>2020/10/07/wang-luo/io/</url>
      
        <content type="html"><![CDATA[<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="1-什么是IO"><a href="#1-什么是IO" class="headerlink" title="1. 什么是IO"></a>1. 什么是IO</h2><p>IO简单理解就是用来传输的工具负责：输入/输出。</p><p>在JDK中有针对不同IO需求的包，比如：</p><ul><li><p>磁盘操作：Paths  Files</p><ul><li>向磁盘写入数据</li><li>从磁盘中读数据</li></ul></li><li><p>字节操作：</p><ul><li>字节流输入操作InputStream </li><li>字节流输出操作Outputstream</li><li>操作byte类型的数据，不会使用缓冲区，直接对文件进行操作，实现文件复制、音频文件处理等</li></ul></li><li><p>字符操作：Writer Reader</p><ul><li>操作字符类型的数据，使用缓冲区，因此必须执行close关闭缓冲区或者flush强制刷新缓冲区才能输出内容，用于编码操作，编码就是把字符转换成字节，解码就是把字节转换成字符。</li><li>OutputStreamWriter 将字符流编码成为字节流</li><li>InputStreamReader 将字节流解码成字符流</li></ul></li><li><p>对象操作Serializable：序列化就是将一个对象转换成字节序列，方便存储和传输</p><ul><li>序列化：ObjectOutputStream.writeObject() </li><li>反序列化：ObjectInputStream.readObject()</li></ul></li><li><p>网络操作：</p><ul><li><p>InetAddress：没有公有的构造函数，只能通过静态方法来创建实例。</p></li><li><p>URL：可以直接从 URL 中读取字节流数据。</p></li><li><p>Socket：</p><ul><li><p>ServerSocket：服务器端类 </p></li><li><p>Socket：客户端类 </p></li><li><p>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</p><p><img src="https://i.loli.net/2020/10/08/poB5AlW4Dc6sEy7.png" alt="scoket2.png"></p></li></ul></li></ul></li></ul><h2 id="2-不同IO模型"><a href="#2-不同IO模型" class="headerlink" title="2. 不同IO模型"></a>2. 不同IO模型</h2><ul><li><p>阻塞IO：在读写数据过程中，如果数据未准备好，则线程会被阻塞直到数据准备好</p></li><li><p>非阻塞IO</p><p>在读写数据过程中，如果数据未准备好，线程无需等待，而是继续执行，重复询问数据是否准备好，但于此同时会消耗大量的内存资源，因为用户线程需要不断地询问内核数据是否就绪，实质上是一直占用着CPU的。</p></li><li><p>复用IO —&gt; NIO</p><p>在多路复用IO模型中，有一个<code>额外的线程</code>不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。只需要一个额外的线程管理多个数据请求线程或进程，只有在数据准备好了之后，请求才会占用CPU资源，因此节省了内存资源。</p></li><li><p>信号驱动IO</p><p>当用户线程发起一个IO请求操作，会给对应的socket注册一个<code>信号函数</code>，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</p></li><li><p>异步IO —&gt; AIO</p><p>在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成，但是异步IO是需要操作系统的底层支持。</p><blockquote><p> 前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</p></blockquote></li></ul><h2 id="3-BIO、NIO、AIO"><a href="#3-BIO、NIO、AIO" class="headerlink" title="3. BIO、NIO、AIO"></a>3. BIO、NIO、AIO</h2><p>BIO：同步阻塞IO，开水例子：用户线程</p><p>NIO：原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。流式处理按字节处理数据，处理简单但是速度较慢，以块的形式读写数据的方法，这使得即使在面向流的系统中处理数据，速度也会更快。</p><p>AIO：异步非阻塞IO。</p><p>假设一个烧开水的场景，有一排水壶在烧开水。</p><p>BIO：用一个线程停留在一个水壶那里，直到这个水壶烧开，才去处理下一个水壶。</p><p>NIO：用一个线程不断地轮询各个水壶的状态，如果水开了，用户线程或者线程过来进行进一步操作（从内核拷贝准备好的数据）</p><p>AIO：给每个水壶安装一个状态开关，如果水壶的水开了（数据读写已经完成），水壶会自动通知系统，用户线程做进一步操作（拿数据）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型中的上下限通配符extends、super</title>
      <link href="2020/10/06/java-ji-chu/java-fan-xing-zhong-de-shang-xia-xian-tong-pei-fu-extends-super/"/>
      <url>2020/10/06/java-ji-chu/java-fan-xing-zhong-de-shang-xia-xian-tong-pei-fu-extends-super/</url>
      
        <content type="html"><![CDATA[<h1 id="Java泛型中的上下限通配符extends、super"><a href="#Java泛型中的上下限通配符extends、super" class="headerlink" title="Java泛型中的上下限通配符extends、super"></a>Java泛型中的上下限通配符extends、super</h1><p>在平时看源码的时候我们经常看到泛型，且经常会看到<code>extends</code>和<code>super</code>的使用，看过其他的文章里也有讲到上界通配符和下届通配符，总感觉讲的不够明白。这里备注一下，以免忘记。</p><ol><li><code>extends</code>也称为上界通配符，就是指定上边界。即泛型中的类必须为当前类的子类或当前类。</li><li><code>super</code>也称为下届通配符，就是指定下边界。即泛型中的类必须为当前类或者其父类。</li></ol><p>这两点不难理解，<code>extends</code>修饰的只能取，不能放，这是为什么呢？</p><p>先看一个列子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Food</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Fruit</span> <span class="token keyword">extends</span> <span class="token class-name">Food</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Banana</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testExtends</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Fruit</span><span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//报错,extends为上界通配符,只能取值,不能放.</span>        <span class="token comment" spellcheck="true">//因为Fruit的子类不只有Apple还有Banana,这里不能确定具体的泛型到底是Apple还是Banana，所以放入任何一种类型都会报错</span>        <span class="token comment" spellcheck="true">//list.add(new Apple());</span>        <span class="token comment" spellcheck="true">//可以正常获取</span>        Fruit fruit <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testSuper</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> Fruit<span class="token operator">></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//super为下界通配符，可以存放元素，但是也只能存放当前类或者子类的实例，以当前的例子来讲，</span>        <span class="token comment" spellcheck="true">//无法确定Fruit的父类是否只有Food一个(Object是超级父类)</span>        <span class="token comment" spellcheck="true">//因此放入Food的实例编译不通过</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//list.add(new Food());</span>        Object object <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在<code>testExtends</code>方法中，因为泛型中用的是<code>extends</code>，在向<code>list</code>中存放元素的时候，我们并不能确定<code>List</code>中的元素的具体类型，即可能是<code>Apple</code>也可能是<code>Banana</code>。因此调用<code>add</code>方法时，不论传入<code>new Apple()</code>还是<code>new Banana()</code>，都会出现编译错误。</p><p>理解了<code>extends</code>之后，再看<code>super</code>就很容易理解了，即我们不能确定<code>testSuper</code>方法的参数中的泛型是<code>Fruit</code>的哪个父类，因此在调用<code>get</code>方法时只能返回<code>Object</code>类型。结合<code>extends</code>可见，在获取泛型元素时，使用<code>extends</code>获取到的是泛型中的上边界的类型(本例子中为Fruit),范围更小。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在使用泛型时，存取元素时用<code>super</code>,获取元素时，用<code>extends</code>。</p><p>本文来源：<a href="https://juejin.im/post/5c653fe06fb9a049e3089d88">https://juejin.im/post/5c653fe06fb9a049e3089d88</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类</title>
      <link href="2020/10/06/java-ji-chu/java-ji-he-lei/"/>
      <url>2020/10/06/java-ji-chu/java-ji-he-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h1><h2 id="1-Collection-和-Collections-区别"><a href="#1-Collection-和-Collections-区别" class="headerlink" title="1. Collection 和 Collections 区别"></a>1. Collection 和 Collections 区别</h2><p>Collection是集合的接口，提供了多个通用的接口方法，供诸如list、set等实现。</p><p>Collections是一个包装类，其内部的方法都为静态方法，因此不能被实例化，作为工具类使用。</p><h2 id="2-常用集合类"><a href="#2-常用集合类" class="headerlink" title="2. 常用集合类"></a>2. 常用集合类</h2><h3 id="1）Set和List的区别"><a href="#1）Set和List的区别" class="headerlink" title="1）Set和List的区别"></a>1）Set和List的区别</h3><p><strong>共同点：</strong>都继承自Collection接口，都用来存储一组相同类型的元素</p><p><strong>不同点：</strong></p><ul><li>list元素按顺序放入，即先来的排在前边且元素是可以重复的</li><li>set元素没有放入顺序，且元素不可重复，所以set可以用来去重</li></ul><h3 id="2）ArrayList-、LinkedList-和-Vector-的区别"><a href="#2）ArrayList-、LinkedList-和-Vector-的区别" class="headerlink" title="2）ArrayList 、LinkedList 和 Vector 的区别"></a>2）ArrayList 、LinkedList 和 Vector 的区别</h3><p><strong>共同点：</strong>ArrayList 和 LinkedList 和 Vector 是List的是三种实现。</p><p><strong>不同点</strong></p><p><strong>ArrayList：</strong>是一个<strong>大小可以改变的数组</strong>，随着数组内元素的增加，其大小将会动态的增加，通过set或者get方法来获取数组内的元素，其查找性能要优于链表，增删性能弱于链表。</p><p><strong>LinkedList：</strong>是一个<strong>双向链表</strong>，增删操作很快，随机访问性能较差。LinkedList还实现了Queue接口，提供了队列相关的操作，比如poll、peek、offer。</p><p><strong>Vector：</strong>与ArrayList类似，但是<strong>Vector是线程安全的</strong>，在没有多个线程共享同一个集合的情况下，建议使用ArrayList。Vector每次请求其大小双倍的空间，而ArrayList每次对size只增长50%。</p><h3 id="4）Set如何保证元素不重复？"><a href="#4）Set如何保证元素不重复？" class="headerlink" title="4）Set如何保证元素不重复？"></a>4）Set如何保证元素不重复？</h3><p>在Java中Set分为两种：TreeSet和HashSet</p><p><strong>TreeSet：</strong>TreeSet的底层是通过TreeMap（红黑树）来实现的，Treeset中的数据是自动排好序的，红黑树实质是一个二叉平衡搜索树，每个节点的左右子树高度不能超过较矮那棵的一倍。</p><p>在TreeSet中插入新元素时，通过调用compareTo()方法来判断元素是否重复，且不允许放入null值。</p><p><strong>HashSet：</strong>HashSet的底层是通过HashMap来实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null。插入新元素时，首先计算新元素的hashcode，再通过扰动计算和按位计算得到此元素在HashMap存储结构中的存放位置，如果此位置为空，则添加此元素，如果不为空，则通过重写了的equal()方法，判断当前插入元素是否与已存在元素相等，如果不相等则添加新元素，相等则不添加。</p><h3 id="5）LinkedHashMap"><a href="#5）LinkedHashMap" class="headerlink" title="5）LinkedHashMap"></a>5）LinkedHashMap</h3><p>继承自HashMap，因此具有快速查找的特性，同时内部维护了一个双向链表，用来维护LRU顺序或者插入顺序。</p><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p><strong>afterNodeAccess()</strong></p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在 每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><p><strong>afterNodeInsertion()</strong></p><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 ﬁrst。</p><p><strong>使用LinkedHashMap实现LRU</strong></p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>accessOrder = true//开启 LRU 顺序</li><li>覆盖 removeEldestEntry()方法，在节点数大于MAX_ENTRIES时会将最近最久未使用的数据移除</li></ul><p>通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><h2 id="3-HashMap的实现原理"><a href="#3-HashMap的实现原理" class="headerlink" title="3. HashMap的实现原理"></a>3. HashMap的实现原理</h2><p><strong>JDK1.7</strong></p><p>HashMap通过<strong>数组+链表</strong>存储数据，内部包含一个Entry类的数组，Entry类包含四个字段，<code>k、v、next、hash</code>来实现数组和链表的结构存储数据。</p><p><strong>插入put：</strong></p><p>在插入新元素时，不同元素的hash值可能相同，也就意味着hash冲突，在1.7版本中解决hash冲突的办法是使用<strong>拉链法</strong>，新插入的元素插入到对应entry链表的头部（头插法），之所以采用头插法是新插入的元素可能更容易被查找。</p><p><strong>常见的解决碰撞的方法</strong></p><ul><li><p>开放定址法</p><p>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p></li><li><p>链地址法</p><p>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</p></li><li><p>再哈希法</p><p>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</p></li><li><p>建立公共溢出区</p><p>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</p></li></ul><p><strong>查找get：</strong></p><ul><li>计算键值对所在的桶Entry</li><li>在链表上顺序查找，时间复杂度与链表的长度成正比，最坏时间复杂度为O(N)</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算hash</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确定桶下标：按位与取模</span></code></pre><p><strong>JDK1.8</strong></p><p>同样使用数组和链表存储数据，但是在一个桶存储的链表长度大于 8 时，会将链表转换为红黑树。这样做是为了避免在链表长度过长时，将遍历链表元素的时间复杂度从O(N)降为O(logN)。</p><p><strong>扩容</strong></p><p>与扩容相关的参数有：：capacity、size、threshold 和 load_factor</p><p>当HashMap存储的元素个数超过threshold过载时<code>threshold = loadFactor * capacity</code>，会触发扩容，且<strong>自动双倍扩容，扩容后重新计算每个键值对位置。</strong></p><p><code>capacity</code>默认为16，且capacity 必须保证为 2 的 n 次方，每次扩容时，capacity 为原来的两倍。size表示当前共有多少个K-V对，当 size 大于等于 threshold 就必须进行扩容操作。loadFactor是负载因子，负载因子一般定为0.75。</p><ul><li><p>为什么负载因子一般定为0.75</p><p>在计算hashmap是否达到扩容标准时，负载因子0.75 = 3/4，与capacity的乘积正好可以为整数。</p></li><li><p>为什么容量必须保证为 2 的 n 次方？</p><p>因为hashmap通过取模获取元素的entry位置时，是通过按位与的方式实现快速查找Entry位置的，而要使得按位与和取余等价则必须保证容量是 2 的 n 次方。</p><pre class=" language-java"><code class="language-java">X <span class="token operator">%</span> <span class="token number">2</span><span class="token operator">^</span>n <span class="token operator">=</span> X <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>n – <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//X表示hash值</span></code></pre></li><li><p>为什么按位与取模？</p><p>这样做的好处是相比于使用“%”取模，不需要将hash转为int计算，节省计算成本，同时按位与的话也避免了复杂的正负计算，因为hash值为int类型</p></li></ul><p><strong>多线程情况下，hashmap扩容会导致死循环问题，出现环形链表</strong></p><h3 id="HashMap多线程操作导致死循环问题"><a href="#HashMap多线程操作导致死循环问题" class="headerlink" title="HashMap多线程操作导致死循环问题"></a>HashMap多线程操作导致死循环问题</h3><p>进行 put 操作会导致 HashMap 死循环，原因在于 HashMap 的扩容 resize()方法。由于扩容是新建一个数组，复制原数据到数组。由于数组下标挂有链表，所以需要复制链表，但是多线程操作有可能导致<strong>环形链表</strong>。</p><h2 id="5-ConcurrentHashMap-的实现原理"><a href="#5-ConcurrentHashMap-的实现原理" class="headerlink" title="5. ConcurrentHashMap 的实现原理"></a>5. ConcurrentHashMap 的实现原理</h2><p><strong>JDK1.7</strong></p><p>在桶数组的基础上，加入了<strong>分段锁</strong>，将数据按分成一段一段的存储，然后给每一段数据分配一个锁，当一个线程访问占用某一段数据的锁，访问此段数据时，其他分段的数据可以被其他线程访问，实现线程安全。</p><p>其核心类为 Segment，它继承自<strong>重入锁 ReentrantLock</strong>，并发度与 Segment 数量相等，默认的并发级别是16。</p><p><strong>JDK1.8</strong></p><p>使用<strong>CAS操作</strong>支持更高的并发量，在CAS操作失败时，使用<strong>内置锁synchronized</strong>，且在链表长度过长时，将转为红黑树来存储数据。</p><h2 id="6-HashMap的长度为什么是2的幂次方"><a href="#6-HashMap的长度为什么是2的幂次方" class="headerlink" title="6. HashMap的长度为什么是2的幂次方"></a>6. HashMap的长度为什么是2的幂次方</h2><p><strong>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀</strong></p><p>Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash ”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p><p><strong>这个算法应该如何设计呢</strong>？<br>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“<strong>取余(%)操作中如果除数是2的幂次则等价于与其除数减1的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率</strong>，这就解释了 HashMap 的长度为什么是2的幂次方。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUnit使用</title>
      <link href="2020/10/06/java-ji-chu/junit/"/>
      <url>2020/10/06/java-ji-chu/junit/</url>
      
        <content type="html"><![CDATA[<h1 id="JUnit使用"><a href="#JUnit使用" class="headerlink" title="JUnit使用"></a>JUnit使用</h1><h2 id="JUnit特性"><a href="#JUnit特性" class="headerlink" title="JUnit特性"></a>JUnit特性</h2><p>JUnit是一个Java语言的单元测试框架，JUnit 促进了“先测试后编码”的理念，强调建立测试数据的一段代码，可以先测试，然后再应用。</p><ul><li><p>一个正式的编写好的单元测试用例的特点是：<strong>已知输入和预期输出，即在测试执行前就已知</strong>。已知输入需要测试的先决条件，预期输出需要测试后置条件。</p></li><li><p>每一项需求至少需要两个单元测试用例：<strong>一个正检验，一个负检验</strong>。如果一个需求有子需求，每一个子需求必须至少有正检验和负检验两个测试用例。</p></li></ul><h2 id="Spring-Boot-基于-JUnit-5-实现单元测试"><a href="#Spring-Boot-基于-JUnit-5-实现单元测试" class="headerlink" title="Spring Boot 基于 JUnit 5 实现单元测试"></a>Spring Boot 基于 JUnit 5 实现单元测试</h2><ol><li><p>创建Springboot工程</p></li><li><p>添加 <code>spring-boot-starter-web</code> 依赖</p></li><li><p>工程创建好后会自动生成一个测试类，用于检查工程的上下文能否正常启动。</p><p><code>@SpringBootTest</code> 注解告诉 Spring Boot 查找带 <code>@SpringBootApplication</code> 注解的主配置类，并使用该类启动 Spring 应用程序上下文。</p></li><li><p>编写业务逻辑测试代码类</p><ul><li>测试类需要添加注解<code>@SpringBootTest</code>，测试方法需要添加<code>@Test</code></li><li>测试方法中调用JUnit中的api来判断测试样例输入输出是否符合既定要求</li></ul></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么时候需要将对象序列化？</title>
      <link href="2020/10/06/java-ji-chu/xu-lie-hua/"/>
      <url>2020/10/06/java-ji-chu/xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="什么时候需要将对象序列化？"><a href="#什么时候需要将对象序列化？" class="headerlink" title="什么时候需要将对象序列化？"></a>什么时候需要将对象序列化？</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p><strong>序列化：</strong>将Java对象转换成字节流的过程</p><p><strong>反序列化：</strong>将字节流转换成Java对象的过程</p><p>为了保障在JVM停止运行后，能够保存对象的状态信息，即成员变量信息，持久化指定的对象，并在将来重新读取被保障的对象。</p><h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h2><ul><li>当Java对象需要在网络中传输时</li><li>当Java对象需要持久化存储到文件中时</li><li>远程方法调用</li></ul><h2 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h2><ul><li><p>只要类实现了Serializable接口（此接口实际上是没有方法的），此类就可以支持被序列化或者反序列化。</p></li><li><p>如果一个类想要被序列化，必须实现Serializable接口，否则将抛出<code>NotSerializableException</code>异常，这是因为在序列化操作的过程中，会对类型进行检查（在writeObject方法中），要求被序列化的类必须属于Enum、Array和Serializable类型其中的任何一种。</p></li><li><p>声明为<strong>static</strong>和<strong>transient</strong>的成员变量，不能被序列化，因此在变量中声明了此关键字，可以组织变量被序列化。</p></li></ul><p>这里需要说明的是ArrayList的<code>transient Object[] elementData</code>声明了<strong>transient</strong>，但是实际上ArrayList依然可以被序列化，这是因为对象的序列化过程实质是通过ObjectOutputStream和ObjectInputputStream来实现，其利用反射的方式调用writeObjectMethod方法，来对ArrayList的元素进行序列化。</p><p><strong>为什么不直接对ArrayList序列化呢？</strong></p><p>ArrayList实际上是动态数组，每次在放满以后自动增长设定的长度值，如果数组自动增长长度设为100，而实际只放了一个元素，那就会序列化99个null元素。为了保证在序列化的时候不会将这么多null同时进行序列化，ArrayList把元素数组设置为transient。这样可以防止一个包含大量空对象的数组被序列化，达到优化存储的效果。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/bubblesort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/bubblesort/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="1-什么是冒泡排序？"><a href="#1-什么是冒泡排序？" class="headerlink" title="1. 什么是冒泡排序？"></a>1. 什么是冒泡排序？</h2><p>冒泡算法顾名思义就是重复地遍历数组中的元素，每次比较两个元素，如果顺序错误就交换位置，接着再比较下一对相邻元素直到最后一个元素确定为最值，接着再重新遍历比较除了有序元素的数组元素。</p><ul><li><strong>从数组末尾位置开始确定排好序的元素，一般为升序，即每次确定最大值放在末位。</strong></li><li>关注点是最大值</li></ul><h2 id="2-代码思路"><a href="#2-代码思路" class="headerlink" title="2. 代码思路"></a>2. 代码思路</h2><ol><li>鲁棒性检查，如果数组为空或者长度小于2直接返回</li><li>因为是从最末位位置开始确定元素，所以从<strong>“末位-&gt;0”</strong>先固定n-1、n-2、n-3、…0位置的元素，固定好后末位依次减1</li><li>在<strong>“末位-0”</strong>范围内，从0位置开始遍历数组并比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个</li></ol><h2 id="3-时间复杂度-amp-空间复杂度"><a href="#3-时间复杂度-amp-空间复杂度" class="headerlink" title="3. 时间复杂度 &amp; 空间复杂度"></a>3. 时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：总共O(N)，额外空间复杂度O(1)</li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//鲁棒性判断</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> end<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer11-旋转数组的最小数字</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/er-fen-cha-zhao/jian-zhi-offer11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/er-fen-cha-zhao/jian-zhi-offer11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer11-旋转数组的最小数字Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#剑指offer11-旋转数组的最小数字Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="剑指offer11-旋转数组的最小数字Find Minimum in Rotated Sorted Array II"></a>剑指offer11-旋转数组的最小数字<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">Find Minimum in Rotated Sorted Array II</a></h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p><pre><code>Example 1:Input: [1,3,5]Output: 1Example 2:Input: [2,2,2,0,1]Output: 0</code></pre><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>二叉树的最大高度，是由其左子树最大高度和右子树的最大高度中取最大值 + 根节点高度 1 计算出来的</li><li>时间复杂度：*<em>O(n)**</em>，空间复杂度：<strong>O(1)</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="2020/10/05/java-ji-chu/string/"/>
      <url>2020/10/05/java-ji-chu/string/</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="1-字符串为什么不可变"><a href="#1-字符串为什么不可变" class="headerlink" title="1. 字符串为什么不可变"></a>1. 字符串为什么不可变</h2><p>因为String被定义为final，初始化定义String的数组不能再引用其他数组，并且String内部没有改变数组中元素的方法，因此String是不可变的。</p><p><strong>java8对Stirng的定义：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>         <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><strong>java9对Stirng的定义：</strong>String 类的实现改用 byte 数组存储字符串，同时使用coder来标识编码类型</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>缓存hash值</strong>：String用作hashmap的key，不可变的特性可以使同样的key的hash值保持不变，使得hashmap只需要一次计算即可得到对应的k-v。</p></li><li><p><strong>满足字符串常量池的需要</strong>：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可使用 String Pool。</p></li><li><p><strong>安全性</strong>：String 作为参数，String 不可变性可以保证参数不可变。比如在网络连接中，如果同一个的连接中，如果String参数是可变的，那么会误认为连接方发生了改变。</p></li><li><p><strong>线程安全</strong>：因为String 中的对象是不可变的，也就可以理解为常量，所以线程安全。</p></li></ul><h2 id="2-String-和-StringBuﬀer、StringBuilder-的区别是什么？"><a href="#2-String-和-StringBuﬀer、StringBuilder-的区别是什么？" class="headerlink" title="2. String 和 StringBuﬀer、StringBuilder 的区别是什么？"></a>2. String 和 StringBuﬀer、StringBuilder 的区别是什么？</h2><p>StringBuilder 与 StringBuﬀer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[]value 但是没有用 ﬁnal 关键字修饰，StringBuilder 与 StringBuﬀer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，所以这两种对象都是可变的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>       <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>       <span class="token keyword">int</span> count<span class="token punctuation">;</span>       <span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>       <span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>线程安全：</strong></p><ul><li>StringBuﬀer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对方法加同步锁，所以是非线程安全的。</li><li>String可以理解为常量，所以线程安全。</li></ul><p><strong>三者使用的总结：</strong></p><ol><li><p>操作少量的数据 = String</p></li><li><p>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</p></li><li><p>多线程操作字符串缓冲区下操作大量数据 = StringBuﬀer</p></li></ol><h1 id="3-String-ValueOf和toString区别"><a href="#3-String-ValueOf和toString区别" class="headerlink" title="3. String.ValueOf和toString区别"></a>3. String.ValueOf和toString区别</h1><p>将对象转换成String类型常用的有如下三种方式：</p><ul><li>(String)[对象]</li><li>[对象].toString</li><li>String.valueOf([对象])</li></ul><p><strong>(String)</strong></p><p>这是标准的类型转换，将对象强制转换为String类型，前提是<strong>该对象必须能保证转成String类型</strong>，否则将抛出ClassCastException异常。</p><p><strong>toString</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** This object (which is already a string!) is itself returned.** @return  the string itself.*/</span><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678</span></code></pre><p>此方法返回对象本身，在java.lang.Object类中也有toString()方法，所以Java对象都可以调用此方法，但使用的时候<strong>必须保证要转换的对象不为null</strong>，否则将抛出NullPointerException异常。</p><p><strong>String.valueOf()</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** Returns the string representation of the &lt;code>Object&lt;/code> argument.** @param   obj   an &lt;code>Object&lt;/code>.* @return  if the argument is &lt;code>null&lt;/code>, then a string equal to*          &lt;code>"null"&lt;/code>; otherwise, the value of*          &lt;code>obj.toString()&lt;/code> is returned.* @see     java.lang.Object#toString()*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">valueOf</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"null"</span> <span class="token operator">:</span> obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从上面源码可以看出，可以不用担心Object为null，但使用的时候也要小心，<strong>当Object为null时，它的返回值是“null”，而不是null</strong>，这是有区别的。</p><h2 id="String有长度限制吗？"><a href="#String有长度限制吗？" class="headerlink" title="String有长度限制吗？"></a>String有长度限制吗？</h2><p>字符串有长度限制，在编译期，要求字符串常量池中的常量不能超过65535(2^16 - 1)，并且在javac执行过程中控制了最大值为65534。</p><p>在运行期，长度不能超过Int的范围，否则会抛异常，因为在其构造函数中，有对Stirng类型的长度的定义：<code>public String(byte bytes[], int offset, int length) </code>根据Integer类的定义，<code>java.lang.Integer#MAX_VALUE</code>的最大值是2^31 - 1。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动拆装箱</title>
      <link href="2020/10/05/java-ji-chu/zi-dong-chai-zhuang-xiang/"/>
      <url>2020/10/05/java-ji-chu/zi-dong-chai-zhuang-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h1><h2 id="什么是包装类型和基本类型，以及自动拆装箱"><a href="#什么是包装类型和基本类型，以及自动拆装箱" class="headerlink" title="什么是包装类型和基本类型，以及自动拆装箱"></a>什么是包装类型和基本类型，以及自动拆装箱</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><ul><li>装箱：自动装箱就是Java自动将原始基本类型值转换成对应的对象，比如将int的变量转换成Integer对象，编译器通过调用valueOf将原始类型值转换成对象</li><li>拆箱：反之将对象转换成基本类型值，比如Integer对象转换成int类型值，编译器通过调用类似intValue()，doubleValue()这类的方法将对象转换成原始类型值</li><li>自动装箱是将boolean值转换成Boolean对象，byte值转换成Byte对象，char转换成Character对象，float值转换成Float对象，int转换成Integer，long转换成Long，short转换成Short，自动拆箱则是相反的操作</li></ul><pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//装箱</span><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拆箱</span></code></pre><h2 id="Integer-的缓存机制"><a href="#Integer-的缓存机制" class="headerlink" title="Integer 的缓存机制"></a>Integer 的缓存机制</h2><p>在调用Integer.valueOf()方法时，Integer封装类型会先判断方法想要的值是否在缓存池中，如果在的话就直接返回缓存池的内容，不在的话就创建一个新的Integer对象。</p><p><strong>在 Java 8 中，Integer 缓存池的大小默认为 -128~127</strong>，上界可通过jvm参数进行调整</p><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false </li><li>all byte values </li><li>short values between -128 and 127 </li><li>int values between -128 and 127 </li><li>char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么说Java是值传递</title>
      <link href="2020/10/05/java-ji-chu/wei-shi-me-shuo-java-shi-zhi-chuan-di/"/>
      <url>2020/10/05/java-ji-chu/wei-shi-me-shuo-java-shi-zhi-chuan-di/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么说-Java-中只有值传递"><a href="#为什么说-Java-中只有值传递" class="headerlink" title="为什么说 Java 中只有值传递"></a>为什么说 Java 中只有值传递</h1><ul><li><strong>值传递</strong>（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li></ul><ul><li><strong>引用传递</strong>（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><p><strong>对于对象参数，值的内容是对象的引用</strong>，简单点说Java中的传递是值传递，而这个值，实际上是对象的引用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="2020/10/05/java-ji-chu/ji-ben-shu-ju-lei-xing/"/>
      <url>2020/10/05/java-ji-chu/ji-ben-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="8-种基本数据类型：整型、浮点型、布尔型、字符型"><a href="#8-种基本数据类型：整型、浮点型、布尔型、字符型" class="headerlink" title="8 种基本数据类型：整型、浮点型、布尔型、字符型"></a>8 种基本数据类型：整型、浮点型、布尔型、字符型</h2><ul><li>byte/8bit </li><li>char/16bit  </li><li>short/16bit  </li><li>int/32bit  </li><li>ﬂoat/32bit  </li><li>long/64bit  </li><li>double/64bit  </li><li>boolean/~</li></ul><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p><h2 id="什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？"><a href="#什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？" class="headerlink" title="什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？"></a>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</h2><p>浮点型简单来说就是表示带有小数的数据</p><p>单精度<code>float</code>、双精度<code>double</code></p><ul><li>单精度浮点数在机内占<code>4</code>个字节、有效数字<code>8</code>位、表示范围：<code>-3.40E+38 ~ +3.40E+38</code></li><li>双精度浮点数在机内占<code>8</code>个字节、有效数字<code>16</code>位、表示范围：<code>-1.79E+308 ~ +1.79E+308</code></li></ul><p>Java默认把小数当做<code>double</code>类型来处理，要想该字面值当做<code>float</code>类型来处理，需要在字面值后面添加<code>F/f</code>,或者强制装换为<code>float</code></p><p>财务涉及到钱的问题，要求精度较高，所以在java中有一个基础的类库名为：<code>java.math.BigDecimal</code>，但这个<code>BigDecimal</code>类型是<strong>引用类型</strong>不是基础类型</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/heapsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/heapsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是堆排序？"><a href="#什么是堆排序？" class="headerlink" title="什么是堆排序？"></a>什么是堆排序？</h2><ol><li><strong>heapinsert:</strong> 先把数组变成大根堆或者小根堆</li><li>把堆顶的元素放到数组最末位，并且固定，即不再扫描，size–</li><li><strong>heapify：</strong>维护当前堆大小范围内的为小根堆或者大根堆</li><li>循环2、3步，直到size为0</li></ol><h4 id="heapinsert（产生大根堆或者小根堆）"><a href="#heapinsert（产生大根堆或者小根堆）" class="headerlink" title="heapinsert（产生大根堆或者小根堆）"></a>heapinsert（产生大根堆或者小根堆）</h4><ul><li><strong>(大根堆)**比较：如果当前位置元素比父亲节点元素值</strong>大**，就交换，当前位置挪向父亲节点索引值，再次重复，直到当前位置元素值不大于父亲节点的值</li><li><strong>(小根堆)**比较：如果当前位置元素比父亲节点元素值</strong>小**，就交换，当前位置挪向父亲节点索引值，再次重复，直到当前位置元素值不大于父亲节点的值</li></ul><h4 id="heapify（在0-size-1范围内维护大根堆或者小根堆）"><a href="#heapify（在0-size-1范围内维护大根堆或者小根堆）" class="headerlink" title="heapify（在0~size-1范围内维护大根堆或者小根堆）"></a>heapify（在0~size-1范围内维护大根堆或者小根堆）</h4><ul><li>在当前位置有孩子情况下，判断左右两个孩子大小</li><li>将孩子中较大的和父亲比</li><li>如果这个孩子比父亲大，那孩子和父亲交换位置</li><li>继续向下扫描直到这个节点到达属于它应该的位置，即它比它的孩子都大</li></ul><p>（实际上是在判断当前的这个节点是不是称职的父亲，即它的值要比它的孩子都大）</p><p><em>Note：</em></p><ul><li>父节点 = （index - 1）/ 2</li><li>子节点（左） = （index * 2）+ 1</li><li>子节点（左） = （index * 2）+ 2</li></ul><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_03_HeapSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> largest <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>            largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> largest<span class="token punctuation">;</span>            left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/incertsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/incertsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是插入排序？"><a href="#什么是插入排序？" class="headerlink" title="什么是插入排序？"></a>什么是插入排序？</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><ul><li><strong>从数组首位开始确定排好序的元素，一般为升序，即每次确定最小值放在首位</strong></li><li>关注点是最小值</li></ul><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N^2)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：O(N)total，O(1)auxiliary</li></ul><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//长度大于2的，从位置1开始遍历比较</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/quicksort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/quicksort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是快速排序？"><a href="#什么是快速排序？" class="headerlink" title="什么是快速排序？"></a>什么是快速排序？</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(NlogN)</li><li>平均时间复杂度：O(NlogN)</li><li>空间复杂度：O(logN) (递归方式)</li></ul><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> less <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> more <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> more<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>less<span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">--</span>more<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> more<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> less <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> more <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/mergesort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/mergesort/</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java">            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p1 <span class="token operator">=</span> left<span class="token punctuation">,</span> p2<span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/selectsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/selectsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是选择排序？"><a href="#什么是选择排序？" class="headerlink" title="什么是选择排序？"></a>什么是选择排序？</h2><p>首先在数组中找最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><ul><li><strong>从数组首位开始确定排好序的元素，一般为升序，即每次确定最小值放在首位</strong></li><li>关注点是最小值</li></ul><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ol><li>从数组首位开始遍历</li><li>定义minIndex（最小值索引）</li><li>遍历比较，找到当前范围minIndex，（比较范围是未排序元素数组范围）</li><li>交换，将当前最小值依次放在数组最左边</li></ol><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N^2)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：O(N)total，O(1)auxiliary</li></ul><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">?</span> j <span class="token operator">:</span> minIndex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer55-二叉树的深度</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer55-er-cha-shu-de-shen-du/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer55-er-cha-shu-de-shen-du/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer55-二叉树的深度Maximum-Depth-of-Binary-Tree"><a href="#剑指offer55-二叉树的深度Maximum-Depth-of-Binary-Tree" class="headerlink" title="剑指offer55-二叉树的深度Maximum Depth of Binary Tree"></a>剑指offer55-二叉树的深度<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree</a></h1><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>Note: A leaf is a node with no children.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>二叉树的最大高度，是由其左子树最大高度和右子树的最大高度中取最大值 + 根节点高度 1 计算出来的</li><li>时间复杂度：*<em>O(n)**</em>，空间复杂度：<strong>O(1)</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer54-二叉搜索树的第k大值</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer54-er-cha-sou-suo-shu-de-di-k-da-zhi/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer54-er-cha-sou-suo-shu-de-di-k-da-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer54-二叉搜索树的第k大值"><a href="#剑指offer54-二叉搜索树的第k大值" class="headerlink" title="剑指offer54-二叉搜索树的第k大值"></a>剑指offer54-二叉搜索树的第k大值</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义全局变量以便返回结果</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> res<span class="token punctuation">,</span> countk<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        countk <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//按“右中左”遍历二叉搜索树，遍历到第k个点即为第k大的点</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>countk <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countk<span class="token operator">--</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>首先明确二叉搜索树的特征<ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li><strong>没有键值相等的节点</strong></li></ul></li><li>二叉搜索树的节点按<strong>中序遍历</strong>（左中右）正好可以构成递增节点序列</li><li>题目要找到第 k 大的节点，所以需要数字降序排列，则将中序遍历按照右、中、左遍历即可，遍历的同时找到第 k 个遍历到的值</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer27-二叉树镜像</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer27-er-cha-shu-jing-xiang/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer27-er-cha-shu-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer27-二叉树镜像-Invert-Binary-Tree"><a href="#剑指offer27-二叉树镜像-Invert-Binary-Tree" class="headerlink" title="剑指offer27-二叉树镜像 Invert Binary Tree"></a>剑指offer27-二叉树镜像<a href="https://leetcode-cn.com/problems/invert-binary-tree/"> Invert Binary Tree</a></h1><p>Invert a binary tree.</p><p>Example:</p><p>Input:</p><pre><code>     4   /   \  2     7 / \   / \1   3 6   9</code></pre><p>Output:</p><pre><code>     4   /   \  7     2 / \   / \9   6 3   1</code></pre><h2 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h2><p>此题并没有要求在原来二叉树的基础上调整二叉树为镜像，也就是说对空间复杂度没有限制，因此可以通过创建节点，根据深度优先策略来创建此二叉树的镜像。时间复杂度可以达到O(n)，但是空间复杂度是以O(n)为代价的。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode res <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//深度优先策略，通过递归的方式遍历二叉树的节点</span>            res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="2020/10/01/shu-ju-ku/shu-ju-ku-shi-wu/"/>
      <url>2020/10/01/shu-ju-ku/shu-ju-ku-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
