<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java集合类</title>
      <link href="2020/10/06/java-ji-chu/java-ji-he-lei/"/>
      <url>2020/10/06/java-ji-chu/java-ji-he-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="Java集合类"><a href="#Java集合类" class="headerlink" title="Java集合类"></a>Java集合类</h1><h2 id="1-Collection-和-Collections-区别"><a href="#1-Collection-和-Collections-区别" class="headerlink" title="1. Collection 和 Collections 区别"></a>1. Collection 和 Collections 区别</h2><p>Collection是集合的接口，提供了多个通用的接口方法，供诸如list、set等实现。</p><p>Collections是一个包装类，其内部的方法都为静态方法，因此不能被实例化，作为工具类使用。</p><h2 id="2-常用集合类"><a href="#2-常用集合类" class="headerlink" title="2. 常用集合类"></a>2. 常用集合类</h2><h3 id="1）Set和List的区别"><a href="#1）Set和List的区别" class="headerlink" title="1）Set和List的区别"></a>1）Set和List的区别</h3><p><strong>共同点：</strong>都继承自Collection接口，都用来存储一组相同类型的元素</p><p><strong>不同点：</strong></p><ul><li>list元素按顺序放入，即先来的排在前边且元素是可以重复的</li><li>set元素没有放入顺序，且元素不可重复，所以set可以用来去重</li></ul><h3 id="2）ArrayList-、LinkedList-和-Vector-的区别"><a href="#2）ArrayList-、LinkedList-和-Vector-的区别" class="headerlink" title="2）ArrayList 、LinkedList 和 Vector 的区别"></a>2）ArrayList 、LinkedList 和 Vector 的区别</h3><p><strong>共同点：</strong>ArrayList 和 LinkedList 和 Vector 是List的是三种实现。</p><p><strong>不同点</strong></p><p><strong>ArrayList：</strong>是一个<strong>大小可以改变的数组</strong>，随着数组内元素的增加，其大小将会动态的增加，通过set或者get方法来获取数组内的元素，其查找性能要优于链表，增删性能弱于链表。</p><p><strong>LinkedList：</strong>是一个<strong>双向链表</strong>，增删操作很快，随机访问性能较差。LinkedList还实现了Queue接口，提供了队列相关的操作，比如poll、peek、offer。</p><p><strong>Vector：</strong>与ArrayList类似，但是<strong>Vector是线程安全的</strong>，在没有多个线程共享同一个集合的情况下，建议使用ArrayList。Vector每次请求其大小双倍的空间，而ArrayList每次对size只增长50%。</p><h3 id="4）Set如何保证元素不重复？"><a href="#4）Set如何保证元素不重复？" class="headerlink" title="4）Set如何保证元素不重复？"></a>4）Set如何保证元素不重复？</h3><p>在Java中Set分为两种：TreeSet和HashSet</p><p><strong>TreeSet：</strong>TreeSet的底层是通过TreeMap（红黑树）来实现的，Treeset中的数据是自动排好序的，红黑树实质是一个二叉平衡搜索树，每个节点的左右子树高度不能超过较矮那棵的一倍。</p><p>在TreeSet中插入新元素时，通过调用compareTo()方法来判断元素是否重复，且不允许放入null值。</p><p><strong>HashSet：</strong>HashSet的底层是通过HashMap来实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null。插入新元素时，首先计算新元素的hashcode，再通过扰动计算和按位计算得到此元素在HashMap存储结构中的存放位置，如果此位置为空，则添加此元素，如果不为空，则通过覆盖了的equal()方法，判断当前插入元素是否与已存在元素相等，如果不相等则添加新元素，相等则不添加。</p><h3 id="5）LinkedHashMap"><a href="#5）LinkedHashMap" class="headerlink" title="5）LinkedHashMap"></a>5）LinkedHashMap</h3><p>继承自HashMap，因此具有快速查找的特性，同时内部维护了一个双向链表，用来维护LRU顺序或者插入顺序。</p><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span> <span class="token keyword">void</span> <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p><strong>afterNodeAccess()</strong></p><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在 每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未 使用的节点。</p><p><strong>afterNodeInsertion()</strong></p><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 ﬁrst。</p><p><strong>使用LinkedHashMap实现LRU</strong></p><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>accessOrder = true//开启 LRU 顺序</li><li>覆盖 removeEldestEntry()方法，在节点数大于MAX_ENTRIES时会将最近最久未使用的数据移除</li></ul><p>通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><h2 id="3-HashMap的实现原理"><a href="#3-HashMap的实现原理" class="headerlink" title="3. HashMap的实现原理"></a>3. HashMap的实现原理</h2><p><strong>JDK1.7</strong></p><p>HashMap通过<strong>数组+链表</strong>存储数据，内部包含一个Entry类的数组，Entry类包含四个字段，<code>k、v、next、hash</code>来实现数组和链表的结构存储数据。</p><p><strong>插入put：</strong></p><p>在插入新元素时，不同元素的hash值可能相同，也就意味着hash冲突，在1.7版本中解决hash冲突的办法是使用<strong>拉链法</strong>，新插入的元素插入到对应entry链表的头部（头插法），之所以采用头插法是新插入的元素可能更容易被查找。</p><p><strong>查找get：</strong></p><ul><li>计算键值对所在的桶Entry</li><li>在链表上顺序查找，时间复杂度与链表的长度成正比，最坏时间复杂度为O(N)</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//计算hash</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//确定桶下标：按位与取模</span></code></pre><p><strong>JDK1.8</strong></p><p>同样使用数组和链表存储数据，但是在一个桶存储的链表长度大于 8 时，会将链表转换为红黑树。这样做是为了避免在链表长度过长时，将遍历链表元素的时间复杂度从O(N)降为O(logN)。</p><p><strong>扩容</strong></p><p>与扩容相关的参数有：：capacity、size、threshold 和 load_factor</p><p>当HashMap存储的元素个数超过threshold过载时<code>threshold = loadFactor * capacity</code>，会触发扩容，<code>capacity</code>默认为16，且capacity 必须保证为 2 的 n 次方，每次扩容时，capacity 为原来的两倍。size表示当前共有多少个K-V对，当 size 大于等于 threshold 就必须进行扩容操作。loadFactor是负载因子，负载因子一般定为0.75。</p><ul><li><p>为什么负载因子一般定为0.75</p><p>在计算hashmap是否达到扩容标准时，负载因子0.75 = 3/4，与capacity的乘积正好可以为整数。</p></li><li><p>为什么容量必须保证为 2 的 n 次方？</p><p>因为hashmap通过取模获取元素的entry位置时，是通过按位与的方式实现快速查找Entry位置的，而要使得按位与和取余等价则必须保证容量是 2 的 n 次方。</p><pre class=" language-java"><code class="language-java">X <span class="token operator">%</span> <span class="token number">2</span><span class="token operator">^</span>n <span class="token operator">=</span> X <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">^</span>n – <span class="token number">1</span><span class="token punctuation">)</span></code></pre></li><li><p>为什么按位与取模？</p><p>这样做的好处是相比于使用“%”取模，不需要将hash转为int计算，节省计算成本，同时按位与的话也避免了复杂的正负计算，因为hash值为int类型</p></li></ul><h2 id="5-ConcurrentHashMap-的实现原理"><a href="#5-ConcurrentHashMap-的实现原理" class="headerlink" title="5. ConcurrentHashMap 的实现原理"></a>5. ConcurrentHashMap 的实现原理</h2><p><strong>JDK1.7</strong></p><p>在桶数组的基础上，加入了<strong>分段锁</strong>，将数据按分成一段一段的存储，然后给每一段数据分配一个锁，当一个线程访问占用某一段数据的锁，访问此段数据时，其他分段的数据可以被其他线程访问，实现线程安全。</p><p>其核心类为 Segment，它继承自<strong>重入锁 ReentrantLock</strong>，并发度与 Segment 数量相等，默认的并发级别是16。</p><p><strong>JDK1.8</strong></p><p>使用<strong>CAS操作</strong>支持更高的并发量，在CAS操作失败时，使用<strong>内置锁synchronized</strong>，且在链表长度过长时，将转为红黑树来存储数据。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化</title>
      <link href="2020/10/06/java-ji-chu/xu-lie-hua/"/>
      <url>2020/10/06/java-ji-chu/xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer11-旋转数组的最小数字</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/er-fen/jian-zhi-offer11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/er-fen/jian-zhi-offer11-xuan-zhuan-shu-zu-de-zui-xiao-shu-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer11-旋转数组的最小数字Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#剑指offer11-旋转数组的最小数字Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="剑指offer11-旋转数组的最小数字Find Minimum in Rotated Sorted Array II"></a>剑指offer11-旋转数组的最小数字<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">Find Minimum in Rotated Sorted Array II</a></h1><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</p><p>Find the minimum element.</p><p>The array may contain duplicates.</p><pre><code>Example 1:Input: [1,3,5]Output: 1Example 2:Input: [2,2,2,0,1]Output: 0</code></pre><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMin</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                right <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                right<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>二叉树的最大高度，是由其左子树最大高度和右子树的最大高度中取最大值 + 根节点高度 1 计算出来的</li><li>时间复杂度：*<em>O(n)**</em>，空间复杂度：<strong>O(1)</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/bubblesort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/bubblesort/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="1-什么是冒泡排序？"><a href="#1-什么是冒泡排序？" class="headerlink" title="1. 什么是冒泡排序？"></a>1. 什么是冒泡排序？</h2><p>冒泡算法顾名思义就是重复地遍历数组中的元素，每次比较两个元素，如果顺序错误就交换位置，接着再比较下一对相邻元素直到最后一个元素确定为最值，接着再重新遍历比较除了有序元素的数组元素。</p><ul><li><strong>从数组末尾位置开始确定排好序的元素，一般为升序，即每次确定最大值放在末位。</strong></li><li>关注点是最大值</li></ul><h2 id="2-代码思路"><a href="#2-代码思路" class="headerlink" title="2. 代码思路"></a>2. 代码思路</h2><ol><li>鲁棒性检查，如果数组为空或者长度小于2直接返回</li><li>因为是从最末位位置开始确定元素，所以从<strong>“末位-&gt;0”</strong>先固定n-1、n-2、n-3、…0位置的元素，固定好后末位依次减1</li><li>在<strong>“末位-0”</strong>范围内，从0位置开始遍历数组并比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个</li></ol><h2 id="3-时间复杂度-amp-空间复杂度"><a href="#3-时间复杂度-amp-空间复杂度" class="headerlink" title="3. 时间复杂度 &amp; 空间复杂度"></a>3. 时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：总共O(N)，额外空间复杂度O(1)</li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//鲁棒性判断</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> end <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> end<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="2020/10/05/java-ji-chu/string/"/>
      <url>2020/10/05/java-ji-chu/string/</url>
      
        <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="1-字符串为什么不可变"><a href="#1-字符串为什么不可变" class="headerlink" title="1. 字符串为什么不可变"></a>1. 字符串为什么不可变</h2><p>因为String被定义为final，初始化定义String的数组不能再引用其他数组，并且String内部没有改变数组中元素的方法，因此String是不可变的。</p><p><strong>java8对Stirng的定义：</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>         <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p><strong>java9对Stirng的定义：</strong>String 类的实现改用 byte 数组存储字符串，同时使用coder来标识编码类型</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">/** The value is used for character storage. */</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>   <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">byte</span> coder<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><p><strong>缓存hash值</strong>：String用作hashmap的key，不可变的特性可以使同样的key的hash值保持不变，使得hashmap只需要一次计算即可得到对应的k-v。</p></li><li><p><strong>满足字符串常量池的需要</strong>：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可使用 String Pool。</p></li><li><p><strong>安全性</strong>：String 作为参数，String 不可变性可以保证参数不可变。比如在网络连接中，如果同一个的连接中，如果String参数是可变的，那么会误认为连接方发生了改变。</p></li><li><p><strong>线程安全</strong>：因为String 中的对象是不可变的，也就可以理解为常量，所以线程安全。</p></li></ul><h2 id="2-String-和-StringBuﬀer、StringBuilder-的区别是什么？"><a href="#2-String-和-StringBuﬀer、StringBuilder-的区别是什么？" class="headerlink" title="2. String 和 StringBuﬀer、StringBuilder 的区别是什么？"></a>2. String 和 StringBuﬀer、StringBuilder 的区别是什么？</h2><p>StringBuilder 与 StringBuﬀer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串 char[]value 但是没有用 ﬁnal 关键字修饰，StringBuilder 与 StringBuﬀer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，所以这两种对象都是可变的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>       <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>       <span class="token keyword">int</span> count<span class="token punctuation">;</span>       <span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>       <span class="token function">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">char</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>线程安全：</strong></p><ul><li>StringBuﬀer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li>StringBuilder 并没有对方法加同步锁，所以是非线程安全的。</li><li>String可以理解为常量，所以线程安全。</li></ul><p><strong>三者使用的总结：**</strong></p><ol><li><p>操作少量的数据 = String</p></li><li><p>单线程操作字符串缓冲区下操作大量数据 = StringBuilder</p></li><li><p>多线程操作字符串缓冲区下操作大量数据 = StringBuﬀer</p></li></ol><h1 id="3-String-ValueOf和toString区别"><a href="#3-String-ValueOf和toString区别" class="headerlink" title="3. String.ValueOf和toString区别"></a>3. String.ValueOf和toString区别</h1><p>将对象转换成String类型常用的有如下三种方式：</p><ul><li>(String)[对象]</li><li>[对象].toString</li><li>String.valueOf([对象])</li></ul><p><strong>(String)</strong></p><p>这是标准的类型转换，将对象强制转换为String类型，前提是<strong>该对象必须能保证转成String类型</strong>，否则将抛出ClassCastException异常。</p><p><strong>toString</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** This object (which is already a string!) is itself returned.** @return  the string itself.*/</span><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token number">12345678</span></code></pre><p>此方法返回对象本身，在java.lang.Object类中也有toString()方法，所以Java对象都可以调用此方法，但使用的时候<strong>必须保证要转换的对象不为null</strong>，否则将抛出NullPointerException异常。</p><p><strong>String.valueOf()</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** Returns the string representation of the &lt;code>Object&lt;/code> argument.** @param   obj   an &lt;code>Object&lt;/code>.* @return  if the argument is &lt;code>null&lt;/code>, then a string equal to*          &lt;code>"null"&lt;/code>; otherwise, the value of*          &lt;code>obj.toString()&lt;/code> is returned.* @see     java.lang.Object#toString()*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">valueOf</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">"null"</span> <span class="token operator">:</span> obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从上面源码可以看出，可以不用担心Object为null，但使用的时候也要小心，<strong>当Object为null时，它的返回值是“null”，而不是null</strong>，这是有区别的。</p><h2 id="String有长度限制吗？"><a href="#String有长度限制吗？" class="headerlink" title="String有长度限制吗？"></a>String有长度限制吗？</h2><p>字符串有长度限制，在编译期，要求字符串常量池中的常量不能超过65535，并且在javac执行过程中控制了最大值为65534。</p><p>在运行期，长度不能超过Int的范围，否则会抛异常。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动拆装箱</title>
      <link href="2020/10/05/java-ji-chu/zi-dong-chai-zhuang-xiang/"/>
      <url>2020/10/05/java-ji-chu/zi-dong-chai-zhuang-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h1><h2 id="什么是包装类型和基本类型，以及自动拆装箱"><a href="#什么是包装类型和基本类型，以及自动拆装箱" class="headerlink" title="什么是包装类型和基本类型，以及自动拆装箱"></a>什么是包装类型和基本类型，以及自动拆装箱</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><ul><li>装箱：自动装箱就是Java自动将原始基本类型值转换成对应的对象，比如将int的变量转换成Integer对象，编译器通过调用valueOf将原始类型值转换成对象</li><li>拆箱：反之将对象转换成基本类型值，比如Integer对象转换成int类型值，编译器通过调用类似intValue()，doubleValue()这类的方法将对象转换成原始类型值</li><li>自动装箱是将boolean值转换成Boolean对象，byte值转换成Byte对象，char转换成Character对象，float值转换成Float对象，int转换成Integer，long转换成Long，short转换成Short，自动拆箱则是相反的操作</li></ul><pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//装箱</span><span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//拆箱</span></code></pre><h2 id="Integer-的缓存机制"><a href="#Integer-的缓存机制" class="headerlink" title="Integer 的缓存机制"></a>Integer 的缓存机制</h2><p>在调用Integer.valueOf()方法时，Integer封装类型会先判断方法想要的值是否在缓存池中，如果在的话就直接返回缓存池的内容，不在的话就创建一个新的Integer对象。</p><p><strong>在 Java 8 中，Integer 缓存池的大小默认为 -128~127</strong>，上界可通过jvm参数进行调整</p><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false </li><li>all byte values </li><li>short values between -128 and 127 </li><li>int values between -128 and 127 </li><li>char in the range \u0000 to \u007F 在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="2020/10/05/java-ji-chu/ji-ben-shu-ju-lei-xing/"/>
      <url>2020/10/05/java-ji-chu/ji-ben-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="8-种基本数据类型：整型、浮点型、布尔型、字符型"><a href="#8-种基本数据类型：整型、浮点型、布尔型、字符型" class="headerlink" title="8 种基本数据类型：整型、浮点型、布尔型、字符型"></a>8 种基本数据类型：整型、浮点型、布尔型、字符型</h2><ul><li>byte/8bit </li><li>char/16bit  </li><li>short/16bit  </li><li>int/32bit  </li><li>ﬂoat/32bit  </li><li>long/64bit  </li><li>double/64bit  </li><li>boolean/~</li></ul><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p><h2 id="什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？"><a href="#什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？" class="headerlink" title="什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？"></a>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</h2><p>浮点型简单来说就是表示带有小数的数据</p><p>单精度<code>float</code>、双精度<code>double</code></p><ul><li>单精度浮点数在机内占<code>4</code>个字节、有效数字<code>8</code>位、表示范围：<code>-3.40E+38 ~ +3.40E+38</code></li><li>双精度浮点数在机内占<code>8</code>个字节、有效数字<code>16</code>位、表示范围：<code>-1.79E+308 ~ +1.79E+308</code></li></ul><p>Java默认把小数当做<code>double</code>类型来处理，要想该字面值当做<code>float</code>类型来处理，需要在字面值后面添加<code>F/f</code>,或者强制装换为<code>float</code></p><p>财务涉及到钱的问题，要求精度较高，所以在java中有一个基础的类库名为：<code>java.math.BigDecimal</code>，但这个<code>BigDecimal</code>类型是<strong>引用类型</strong>不是基础类型</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么说Java是值传递</title>
      <link href="2020/10/05/java-ji-chu/wei-shi-me-shuo-java-shi-zhi-chuan-di/"/>
      <url>2020/10/05/java-ji-chu/wei-shi-me-shuo-java-shi-zhi-chuan-di/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么说-Java-中只有值传递"><a href="#为什么说-Java-中只有值传递" class="headerlink" title="为什么说 Java 中只有值传递"></a>为什么说 Java 中只有值传递</h1><ul><li><strong>值传递</strong>（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li></ul><ul><li><strong>引用传递</strong>（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><p><strong>对于对象参数，值的内容是对象的引用</strong>，简单点说Java中的传递是值传递，而这个值，实际上是对象的引用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/quicksort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/quicksort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是快速排序？"><a href="#什么是快速排序？" class="headerlink" title="什么是快速排序？"></a>什么是快速排序？</h2><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(NlogN)</li><li>平均时间复杂度：O(NlogN)</li><li>空间复杂度：O(logN) (递归方式)</li></ul><p><strong>代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> l<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> less <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> more <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> more<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>less<span class="token punctuation">,</span> l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">--</span>more<span class="token punctuation">,</span> l<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> more<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> less <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> more <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/heapsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/heapsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是堆排序？"><a href="#什么是堆排序？" class="headerlink" title="什么是堆排序？"></a>什么是堆排序？</h2><ol><li><strong>heapinsert:</strong> 先把数组变成大根堆或者小根堆</li><li>把堆顶的元素放到数组最末位，并且固定，即不再扫描，size–</li><li><strong>heapify：</strong>维护当前堆大小范围内的为小根堆或者大根堆</li><li>循环2、3步，直到size为0</li></ol><h4 id="heapinsert（产生大根堆或者小根堆）"><a href="#heapinsert（产生大根堆或者小根堆）" class="headerlink" title="heapinsert（产生大根堆或者小根堆）"></a>heapinsert（产生大根堆或者小根堆）</h4><ul><li><strong>(大根堆)**比较：如果当前位置元素比父亲节点元素值</strong>大**，就交换，当前位置挪向父亲节点索引值，再次重复，直到当前位置元素值不大于父亲节点的值</li><li><strong>(小根堆)**比较：如果当前位置元素比父亲节点元素值</strong>小**，就交换，当前位置挪向父亲节点索引值，再次重复，直到当前位置元素值不大于父亲节点的值</li></ul><h4 id="heapify（在0-size-1范围内维护大根堆或者小根堆）"><a href="#heapify（在0-size-1范围内维护大根堆或者小根堆）" class="headerlink" title="heapify（在0~size-1范围内维护大根堆或者小根堆）"></a>heapify（在0~size-1范围内维护大根堆或者小根堆）</h4><ul><li>在当前位置有孩子情况下，判断左右两个孩子大小</li><li>将孩子中较大的和父亲比</li><li>如果这个孩子比父亲大，那孩子和父亲交换位置</li><li>继续向下扫描直到这个节点到达属于它应该的位置，即它比它的孩子都大</li></ul><p>（实际上是在判断当前的这个节点是不是称职的父亲，即它的值要比它的孩子都大）</p><p><em>Note：</em></p><ul><li>父节点 = （index - 1）/ 2</li><li>子节点（左） = （index * 2）+ 1</li><li>子节点（左） = （index * 2）+ 2</li></ul><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Code_03_HeapSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapInsert</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> largest <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> size <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> left <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>            largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            index <span class="token operator">=</span> largest<span class="token punctuation">;</span>            left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/incertsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/incertsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是插入排序？"><a href="#什么是插入排序？" class="headerlink" title="什么是插入排序？"></a>什么是插入排序？</h2><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><ul><li><strong>从数组首位开始确定排好序的元素，一般为升序，即每次确定最小值放在首位</strong></li><li>关注点是最小值</li></ul><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N^2)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：O(N)total，O(1)auxiliary</li></ul><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//长度大于2的，从位置1开始遍历比较</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j<span class="token punctuation">,</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/mergesort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/mergesort/</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java">            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p1 <span class="token operator">=</span> left<span class="token punctuation">,</span> p2<span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>            help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>left <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/selectsort/"/>
      <url>2020/10/05/shu-ju-jie-gou-yu-suan-fa/pai-xu/selectsort/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是选择排序？"><a href="#什么是选择排序？" class="headerlink" title="什么是选择排序？"></a>什么是选择排序？</h2><p>首先在数组中找最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><ul><li><strong>从数组首位开始确定排好序的元素，一般为升序，即每次确定最小值放在首位</strong></li><li>关注点是最小值</li></ul><h2 id="代码思路"><a href="#代码思路" class="headerlink" title="代码思路"></a>代码思路</h2><ol><li>从数组首位开始遍历</li><li>定义minIndex（最小值索引）</li><li>遍历比较，找到当前范围minIndex，（比较范围是未排序元素数组范围）</li><li>交换，将当前最小值依次放在数组最左边</li></ol><h2 id="时间复杂度-amp-空间复杂度"><a href="#时间复杂度-amp-空间复杂度" class="headerlink" title="时间复杂度 &amp; 空间复杂度"></a>时间复杂度 &amp; 空间复杂度</h2><ul><li>最坏时间复杂度：O(N^2)</li><li>最优时间复杂度：O(N^2)</li><li>平均时间复杂度：O(N^2)</li><li>最坏空间复杂度：O(N)total，O(1)auxiliary</li></ul><h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectionSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">?</span> j <span class="token operator">:</span> minIndex<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer55-二叉树的深度</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer55-er-cha-shu-de-shen-du/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer55-er-cha-shu-de-shen-du/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer55-二叉树的深度Maximum-Depth-of-Binary-Tree"><a href="#剑指offer55-二叉树的深度Maximum-Depth-of-Binary-Tree" class="headerlink" title="剑指offer55-二叉树的深度Maximum Depth of Binary Tree"></a>剑指offer55-二叉树的深度<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Maximum Depth of Binary Tree</a></h1><p>Given a binary tree, find its maximum depth.</p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p><p>Note: A leaf is a node with no children.</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>二叉树的最大高度，是由其左子树最大高度和右子树的最大高度中取最大值 + 根节点高度 1 计算出来的</li><li>时间复杂度：*<em>O(n)**</em>，空间复杂度：<strong>O(1)</strong></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer54-二叉搜索树的第k大值</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer54-er-cha-sou-suo-shu-de-di-k-da-zhi/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer54-er-cha-sou-suo-shu-de-di-k-da-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer54-二叉搜索树的第k大值"><a href="#剑指offer54-二叉搜索树的第k大值" class="headerlink" title="剑指offer54-二叉搜索树的第k大值"></a>剑指offer54-二叉搜索树的第k大值</h1><p>给定一棵二叉搜索树，请找出其中第k大的节点。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//定义全局变量以便返回结果</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> res<span class="token punctuation">,</span> countk<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">kthLargest</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        countk <span class="token operator">=</span> k<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//按“右中左”遍历二叉搜索树，遍历到第k个点即为第k大的点</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode node<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>countk <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        countk<span class="token operator">--</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Thought"><a href="#Thought" class="headerlink" title="Thought"></a>Thought</h2><ul><li>首先明确二叉搜索树的特征<ul><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li><li><strong>没有键值相等的节点</strong></li></ul></li><li>二叉搜索树的节点按<strong>中序遍历</strong>（左中右）正好可以构成递增节点序列</li><li>题目要找到第 k 大的节点，所以需要数字降序排列，则将中序遍历按照右、中、左遍历即可，遍历的同时找到第 k 个遍历到的值</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer27-二叉树镜像</title>
      <link href="2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer27-er-cha-shu-jing-xiang/"/>
      <url>2020/10/04/shu-ju-jie-gou-yu-suan-fa/dfs/jian-zhi-offer27-er-cha-shu-jing-xiang/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer27-二叉树镜像-Invert-Binary-Tree"><a href="#剑指offer27-二叉树镜像-Invert-Binary-Tree" class="headerlink" title="剑指offer27-二叉树镜像 Invert Binary Tree"></a>剑指offer27-二叉树镜像<a href="https://leetcode-cn.com/problems/invert-binary-tree/"> Invert Binary Tree</a></h1><p>Invert a binary tree.</p><p>Example:</p><p>Input:</p><pre><code>     4   /   \  2     7 / \   / \1   3 6   9</code></pre><p>Output:</p><pre><code>     4   /   \  7     2 / \   / \9   6 3   1</code></pre><h2 id="Thoughts"><a href="#Thoughts" class="headerlink" title="Thoughts"></a>Thoughts</h2><p>此题并没有要求在原来二叉树的基础上调整二叉树为镜像，也就是说对空间复杂度没有限制，因此可以通过创建节点，根据深度优先策略来创建此二叉树的镜像。时间复杂度可以达到O(n)，但是空间复杂度是以O(n)为代价的。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">invertTree</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode res <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//深度优先策略，通过递归的方式遍历二叉树的节点</span>            res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            res<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 剑指offer </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="2020/10/01/shu-ju-ku/shu-ju-ku-shi-wu/"/>
      <url>2020/10/01/shu-ju-ku/shu-ju-ku-shi-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/01/java-ji-chu/java-zhong-de-guan-jian-zi/"/>
      <url>2020/10/01/java-ji-chu/java-zhong-de-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2020/10/01/java-ji-chu/template/"/>
      <url>2020/10/01/java-ji-chu/template/</url>
      
        <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
